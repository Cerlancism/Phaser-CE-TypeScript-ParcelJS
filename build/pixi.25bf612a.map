{"version":3,"sources":["../node_modules/phaser-ce/build/custom/pixi.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pixi.25bf612a.map","sourceRoot":"..\\src","sourcesContent":["/**\n* @author       Richard Davey <rich@photonstorm.com>\n* @copyright    2016 Photon Storm Ltd.\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*\n* @overview\n*\n* Phaser - http://phaser.io\n*\n* v2.11.1 \"2018-10-02\" - Built: Tue Oct 02 2018 18:19:32\n*\n* By Richard Davey http://www.photonstorm.com @photonstorm\n*\n* Phaser is a fun, free and fast 2D game framework for making HTML5 games\n* for desktop and mobile web browsers, supporting Canvas and WebGL rendering.\n*\n* Phaser uses Pixi.js for rendering, created by Mat Groves http://matgroves.com @Doormat23\n* Phaser uses p2.js for full-body physics, created by Stefan Hedman https://github.com/schteppe/p2.js @schteppe\n* Phaser contains a port of N+ Physics, converted by Richard Davey, original by http://www.metanetsoftware.com\n*\n* Many thanks to Adam Saltsman (@ADAMATOMIC) for releasing Flixel, from which both Phaser and my love of framework development originate.\n*\n* Follow development at http://phaser.io and on our forum\n*\n* \"If you want your children to be intelligent,  read them fairy tales.\"\n* \"If you want them to be more intelligent, read them more fairy tales.\"\n*                                                     -- Albert Einstein\n*/\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n(function(){\n\n    var root = this;\n\n/**\n * Namespace-class for [pixi.js](http://www.pixijs.com/).\n *\n * Contains assorted static properties and enumerations.\n *\n * @namespace PIXI\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\nvar PIXI = PIXI || {};\n\n/**\n* @author       Mat Groves http://matgroves.com @Doormat23\n* @author       Richard Davey <rich@photonstorm.com>\n* @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}\n*/\n\n/**\n* The base class for all objects that are rendered. Contains properties for position, scaling,\n* rotation, masks and cache handling.\n*\n* This is an abstract class and should not be used on its own, rather it should be extended.\n*\n* It is used internally by the likes of PIXI.Sprite.\n*\n* @class PIXI.DisplayObject\n* @constructor\n*/\nPIXI.DisplayObject = function ()\n{\n\n    /**\n    * The coordinates, in pixels, of this DisplayObject, relative to its parent container.\n    *\n    * The value of this property does not reflect any positioning happening further up the display list.\n    * To obtain that value please see the `worldPosition` property.\n    *\n    * @property {PIXI.Point} position\n    * @default\n    */\n    this.position = new PIXI.Point(0, 0);\n\n    /**\n    * The scale of this DisplayObject. A scale of 1:1 represents the DisplayObject\n    * at its default size. A value of 0.5 would scale this DisplayObject by half, and so on.\n    *\n    * The value of this property does not reflect any scaling happening further up the display list.\n    * To obtain that value please see the `worldScale` property.\n    *\n    * @property {PIXI.Point} scale\n    * @default\n    */\n    this.scale = new PIXI.Point(1, 1);\n\n    /**\n    * The pivot point of this DisplayObject that it rotates around. The values are expressed\n    * in pixel values.\n    * @property {PIXI.Point} pivot\n    * @default\n    */\n    this.pivot = new PIXI.Point(0, 0);\n\n    /**\n    * The rotation of this DisplayObject. The value is given, and expressed, in radians, and is based on\n    * a right-handed orientation.\n    *\n    * The value of this property does not reflect any rotation happening further up the display list.\n    * To obtain that value please see the `worldRotation` property.\n    *\n    * @property {number} rotation\n    * @default\n    */\n    this.rotation = 0;\n\n    /**\n    * The alpha value of this DisplayObject. A value of 1 is fully opaque. A value of 0 is transparent.\n    * Please note that an object with an alpha value of 0 is skipped during the render pass.\n    *\n    * The value of this property does not reflect any alpha values set further up the display list.\n    * To obtain that value please see the `worldAlpha` property.\n    *\n    * @property {number} alpha\n    * @default\n    */\n    this.alpha = 1;\n\n    /**\n    * The visibility of this DisplayObject. A value of `false` makes the object invisible.\n    * A value of `true` makes it visible.\n    *\n    * An object with a visible value of `false` is skipped during the render pass.\n    * Equally a DisplayObject with visible `false` will not render any of its children.\n    *\n    * The value of this property does not reflect any visible values set further up the display list.\n    * To obtain that value please see the {@link #worldVisible} property.\n    *\n    * Objects that are not {@link #worldVisible} do not update their {@link #worldPosition}.\n    *\n    * @property {boolean} visible\n    * @default\n    */\n    this.visible = true;\n\n    /**\n     * This is the defined area that will pick up mouse / touch events. It is null by default.\n     * Setting it is a neat way of optimising the hitTest function that the interactionManager will use (as it will not need to hit test all the children)\n     *\n     * @property hitArea\n     * @type Rectangle|Circle|Ellipse|Polygon\n     */\n    this.hitArea = null;\n\n    /**\n    * Should this DisplayObject be rendered by the renderer? An object with a renderable value of\n    * `false` is skipped during the render pass.\n    *\n    * @property {boolean} renderable\n    * @default\n    */\n    this.renderable = false;\n\n    /**\n    * The parent DisplayObjectContainer that this DisplayObject is a child of.\n    * All DisplayObjects must belong to a parent in order to be rendered.\n    * The root parent is the Stage object. This property is set automatically when the\n    * DisplayObject is added to, or removed from, a DisplayObjectContainer.\n    *\n    * @property {PIXI.DisplayObjectContainer} parent\n    * @default\n    * @readOnly\n    */\n    this.parent = null;\n\n    /**\n    * The multiplied alpha value of this DisplayObject. A value of 1 is fully opaque. A value of 0 is transparent.\n    * This value is the calculated total, based on the alpha values of all parents of this DisplayObjects\n    * in the display list.\n    *\n    * To obtain, and set, the local alpha value, see the `alpha` property.\n    *\n    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until\n    * that happens this property will contain values based on the previous frame. Be mindful of this if\n    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.\n    *\n    * @property {number} worldAlpha\n    * @readOnly\n    */\n    this.worldAlpha = 1;\n\n    /**\n    * The current transform of this DisplayObject.\n    *\n    * This property contains the calculated total, based on the transforms of all parents of this\n    * DisplayObject in the display list.\n    *\n    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until\n    * that happens this property will contain values based on the previous frame. Be mindful of this if\n    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.\n    *\n    * @property {Phaser.Matrix} worldTransform\n    * @readOnly\n    */\n    this.worldTransform = new Phaser.Matrix();\n\n    /**\n    * The coordinates, in pixels, of this DisplayObject within the world.\n    *\n    * This property contains the calculated total, based on the positions of all parents of this\n    * DisplayObject in the display list.\n    *\n    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until\n    * that happens this property will contain values based on the previous frame. Be mindful of this if\n    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.\n    *\n    * @property {PIXI.Point} worldPosition\n    * @readOnly\n    */\n    this.worldPosition = new PIXI.Point(0, 0);\n\n    /**\n    * The global scale of this DisplayObject.\n    *\n    * This property contains the calculated total, based on the scales of all parents of this\n    * DisplayObject in the display list.\n    *\n    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until\n    * that happens this property will contain values based on the previous frame. Be mindful of this if\n    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.\n    *\n    * @property {PIXI.Point} worldScale\n    * @readOnly\n    */\n    this.worldScale = new PIXI.Point(1, 1);\n\n    /**\n    * The rotation, in radians, of this DisplayObject.\n    *\n    * This property contains the calculated total, based on the rotations of all parents of this\n    * DisplayObject in the display list.\n    *\n    * Note: This property is only updated at the end of the `updateTransform` call, once per render. Until\n    * that happens this property will contain values based on the previous frame. Be mindful of this if\n    * accessing this property outside of the normal game flow, i.e. from an asynchronous event callback.\n    *\n    * @property {number} worldRotation\n    * @readOnly\n    */\n    this.worldRotation = 0;\n\n    /**\n    * The rectangular area used by filters when rendering a shader for this DisplayObject.\n    *\n    * @property {PIXI.Rectangle} filterArea\n    * @type Rectangle\n    * @default\n    */\n    this.filterArea = null;\n\n    /**\n    * @property {number} _sr - Cached rotation value.\n    * @private\n    */\n    this._sr = 0;\n\n    /**\n    * @property {number} _cr - Cached rotation value.\n    * @private\n    */\n    this._cr = 1;\n\n    /**\n    * @property {PIXI.Rectangle} _bounds - The cached bounds of this object.\n    * @private\n    */\n    this._bounds = new PIXI.Rectangle(0, 0, 0, 0);\n\n    /**\n    * @property {PIXI.Rectangle} _currentBounds - The most recently calculated bounds of this object.\n    * @private\n    */\n    this._currentBounds = null;\n\n    /**\n    * @property {PIXI.Rectangle} _mask - The cached mask of this object.\n    * @private\n    */\n    this._mask = null;\n\n    /**\n    * @property {boolean} _cacheAsBitmap - Internal cache as bitmap flag.\n    * @private\n    */\n    this._cacheAsBitmap = false;\n\n    /**\n    * @property {boolean} _cacheIsDirty - Internal dirty cache flag.\n    * @private\n    */\n    this._cacheIsDirty = false;\n\n};\n\nPIXI.DisplayObject.prototype = {\n\n    constructor: PIXI.DisplayObject,\n\n    /**\n    * Destroy this DisplayObject.\n    *\n    * Removes any cached sprites, sets renderable flag to false, and nulls filters, bounds and mask.\n    *\n    * Also iteratively calls `destroy` on any children.\n    *\n    * @method PIXI.DisplayObject#destroy\n    */\n    destroy: function ()\n    {\n\n        if (this.children)\n        {\n            var i = this.children.length;\n\n            while (i--)\n            {\n                this.children[i].destroy();\n            }\n\n            this.children = [];\n        }\n\n        this.hitArea = null;\n        this.parent = null;\n        this.worldTransform = null;\n        this.filterArea = null;\n        this.renderable = false;\n\n        this._bounds = null;\n        this._currentBounds = null;\n        this._mask = null;\n\n        this._destroyCachedSprite();\n\n    },\n\n    /**\n    * Updates the transform matrix this DisplayObject uses for rendering.\n    *\n    * If the object has no parent, and no parent parameter is provided, it will default to\n    * Phaser.Game.World as the parent transform to use. If that is unavailable the transform fails to take place.\n    *\n    * The `parent` parameter has priority over the actual parent. Use it as a parent override.\n    * Setting it does **not** change the actual parent of this DisplayObject.\n    *\n    * Calling this method updates the `worldTransform`, `worldAlpha`, `worldPosition`, `worldScale`\n    * and `worldRotation` properties.\n    *\n    * If a `transformCallback` has been specified, it is called at the end of this method, and is passed\n    * the new, updated, worldTransform property, along with the parent transform used.\n    *\n    * @method PIXI.DisplayObject#updateTransform\n    * @param {PIXI.DisplayObjectContainer} [parent] - Optional parent to calculate this DisplayObjects transform from.\n    * @return {PIXI.DisplayObject} - A reference to this DisplayObject.\n    */\n    updateTransform: function (parent)\n    {\n\n        if (!parent && !this.parent && !this.game)\n        {\n            return this;\n        }\n\n        var p = this.parent;\n\n        if (parent)\n        {\n            p = parent;\n        }\n        else if (!this.parent)\n        {\n            p = this.game.world;\n        }\n\n        // create some matrix refs for easy access\n        var pt = p.worldTransform;\n        var wt = this.worldTransform;\n\n        // temporary matrix variables\n        var a, b, c, d, tx, ty;\n\n        // so if rotation is between 0 then we can simplify the multiplication process..\n        if (this.rotation % Phaser.Math.PI2)\n        {\n            // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes\n            if (this.rotation !== this.rotationCache)\n            {\n                this.rotationCache = this.rotation;\n                this._sr = Math.sin(this.rotation);\n                this._cr = Math.cos(this.rotation);\n            }\n\n            // get the matrix values of the displayobject based on its transform properties..\n            a = this._cr * this.scale.x;\n            b = this._sr * this.scale.x;\n            c = -this._sr * this.scale.y;\n            d = this._cr * this.scale.y;\n            tx = this.position.x;\n            ty = this.position.y;\n\n            // check for pivot.. not often used so geared towards that fact!\n            if (this.pivot.x || this.pivot.y)\n            {\n                tx -= this.pivot.x * a + this.pivot.y * c;\n                ty -= this.pivot.x * b + this.pivot.y * d;\n            }\n\n            // concat the parent matrix with the objects transform.\n            wt.a = a * pt.a + b * pt.c;\n            wt.b = a * pt.b + b * pt.d;\n            wt.c = c * pt.a + d * pt.c;\n            wt.d = c * pt.b + d * pt.d;\n            wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n            wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n        }\n        else\n        {\n            // lets do the fast version as we know there is no rotation..\n            a = this.scale.x;\n            b = 0;\n            c = 0;\n            d = this.scale.y;\n            tx = this.position.x - this.pivot.x * a;\n            ty = this.position.y - this.pivot.y * d;\n\n            wt.a = a * pt.a;\n            wt.b = a * pt.b;\n            wt.c = d * pt.c;\n            wt.d = d * pt.d;\n            wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n            wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n        }\n\n        a = wt.a;\n        b = wt.b;\n        c = wt.c;\n        d = wt.d;\n\n        var determ = (a * d) - (b * c);\n\n        if (a || b)\n        {\n            var r = Math.sqrt((a * a) + (b * b));\n\n            this.worldRotation = (b > 0) ? Math.acos(a / r) : -Math.acos(a / r);\n            this.worldScale.x = r;\n            this.worldScale.y = determ / r;\n        }\n        else if (c || d)\n        {\n            var s = Math.sqrt((c * c) + (d * d));\n\n            this.worldRotation = Phaser.Math.HALF_PI - ((d > 0) ? Math.acos(-c / s) : -Math.acos(c / s));\n            this.worldScale.x = determ / s;\n            this.worldScale.y = s;\n        }\n        else\n        {\n            this.worldScale.x = 0;\n            this.worldScale.y = 0;\n        }\n\n        //  Set the World values\n        this.worldAlpha = this.alpha * p.worldAlpha;\n        this.worldPosition.x = wt.tx;\n        this.worldPosition.y = wt.ty;\n\n        // reset the bounds each time this is called!\n        this._currentBounds = null;\n\n        //  Custom callback?\n        if (this.transformCallback)\n        {\n            this.transformCallback.call(this.transformCallbackContext, wt, pt);\n        }\n\n        return this;\n\n    },\n\n    /**\n    * To be overridden by classes that require it.\n    *\n    * @method PIXI.DisplayObject#preUpdate\n    */\n    preUpdate: function ()\n    {\n\n    },\n\n    /**\n    * Generates a RenderTexture based on this DisplayObject, which can they be used to texture other Sprites.\n    * This can be useful if your DisplayObject is static, or complicated, and needs to be reused multiple times.\n    *\n    * Please note that no garbage collection takes place on old textures. It is up to you to destroy old textures,\n    * and references to them, so they don't linger in memory.\n    *\n    * @method PIXI.DisplayObject#generateTexture\n    * @param {number} [resolution=1] - The resolution of the texture being generated.\n    * @param {number} [scaleMode=PIXI.scaleModes.DEFAULT] - See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values.\n    * @param {PIXI.CanvasRenderer|PIXI.WebGLRenderer} renderer - The renderer used to generate the texture.\n    * @return {Phaser.RenderTexture} - A RenderTexture containing an image of this DisplayObject at the time it was invoked.\n    */\n    generateTexture: function (resolution, scaleMode, renderer)\n    {\n\n        var bounds = this.getLocalBounds();\n\n        var renderTexture = new Phaser.RenderTexture(this.game, bounds.width | 0, bounds.height | 0, renderer, scaleMode, resolution);\n\n        PIXI.DisplayObject._tempMatrix.tx = -bounds.x;\n        PIXI.DisplayObject._tempMatrix.ty = -bounds.y;\n\n        renderTexture.render(this, PIXI.DisplayObject._tempMatrix);\n\n        return renderTexture;\n\n    },\n\n    /**\n    * If this DisplayObject has a cached Sprite, this method generates and updates it.\n    *\n    * @method PIXI.DisplayObject#updateCache\n    * @return {PIXI.DisplayObject} - A reference to this DisplayObject.\n    */\n    updateCache: function ()\n    {\n\n        this._generateCachedSprite();\n\n        return this;\n\n    },\n\n    /**\n    * Calculates the global position of this DisplayObject, based on the position given.\n    *\n    * @method PIXI.DisplayObject#toGlobal\n    * @param {PIXI.Point} position - The global position to calculate from.\n    * @return {PIXI.Point} - A point object representing the position of this DisplayObject based on the global position given.\n    */\n    toGlobal: function (position)\n    {\n\n        this.updateTransform();\n\n        return this.worldTransform.apply(position);\n\n    },\n\n    /**\n    * Calculates the local position of this DisplayObject, relative to another point.\n    *\n    * @method PIXI.DisplayObject#toLocal\n    * @param {PIXI.Point} position - The world origin to calculate from.\n    * @param {PIXI.DisplayObject} [from] - An optional DisplayObject to calculate the global position from.\n    * @return {PIXI.Point} - A point object representing the position of this DisplayObject based on the global position given.\n    */\n    toLocal: function (position, from)\n    {\n\n        if (from)\n        {\n            position = from.toGlobal(position);\n        }\n\n        this.updateTransform();\n\n        return this.worldTransform.applyInverse(position);\n\n    },\n\n    /**\n    * Internal method.\n    *\n    * @method PIXI.DisplayObject#_renderCachedSprite\n    * @private\n    * @param {Object} renderSession - The render session\n    */\n    _renderCachedSprite: function (renderSession)\n    {\n\n        this._cachedSprite.worldAlpha = this.worldAlpha;\n\n        if (renderSession.gl)\n        {\n            PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, renderSession);\n        }\n        else\n        {\n            PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, renderSession);\n        }\n\n    },\n\n    /**\n    * Internal method.\n    *\n    * @method PIXI.DisplayObject#_generateCachedSprite\n    * @private\n    */\n    _generateCachedSprite: function ()\n    {\n\n        this._cacheAsBitmap = false;\n\n        var bounds = this.getLocalBounds();\n\n        //  Round it off and force non-zero dimensions\n        bounds.width = Math.max(1, Math.ceil(bounds.width));\n        bounds.height = Math.max(1, Math.ceil(bounds.height));\n\n        this.updateTransform();\n\n        if (!this._cachedSprite)\n        {\n            var textureUnit = 0;\n            if (this.texture && this.texture.baseTexture && PIXI._enableMultiTextureToggle)\n            {\n                textureUnit = this.texture.baseTexture.textureIndex;\n            }\n            var renderTexture = new Phaser.RenderTexture(this.game, bounds.width, bounds.height, undefined, undefined, undefined, undefined, textureUnit);\n            this._cachedSprite = new PIXI.Sprite(renderTexture);\n            this._cachedSprite.worldTransform = this.worldTransform;\n        }\n        else\n        {\n            this._cachedSprite.texture.resize(bounds.width, bounds.height);\n        }\n\n        //  Remove filters\n        var tempFilters = this._filters;\n\n        this._filters = null;\n        this._cachedSprite.filters = tempFilters;\n\n        PIXI.DisplayObject._tempMatrix.tx = -bounds.x;\n        PIXI.DisplayObject._tempMatrix.ty = -bounds.y;\n        this._cachedSprite.texture.render(this, PIXI.DisplayObject._tempMatrix, true);\n        this._cachedSprite.anchor.x = -(bounds.x / bounds.width);\n        this._cachedSprite.anchor.y = -(bounds.y / bounds.height);\n\n        this._filters = tempFilters;\n\n        this._cacheAsBitmap = true;\n\n    },\n\n    /**\n    * Destroys a cached Sprite.\n    *\n    * @method PIXI.DisplayObject#_destroyCachedSprite\n    * @private\n    */\n    _destroyCachedSprite: function ()\n    {\n\n        if (!this._cachedSprite)\n        {\n            return;\n        }\n\n        this._cachedSprite.texture.destroy(true);\n\n        this._cachedSprite = null;\n\n    }\n\n};\n\n//  Alias for updateTransform. As used in DisplayObject container, etc.\nPIXI.DisplayObject.prototype.displayObjectUpdateTransform = PIXI.DisplayObject.prototype.updateTransform;\n\nObject.defineProperties(PIXI.DisplayObject.prototype, {\n\n    /**\n    * The horizontal position of the DisplayObject, in pixels, relative to its parent.\n    * If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.\n    * @name PIXI.DisplayObject#x\n    * @property {number} x - The horizontal position of the DisplayObject, in pixels, relative to its parent.\n    */\n    x: {\n\n        get: function ()\n        {\n\n            return this.position.x;\n\n        },\n\n        set: function (value)\n        {\n\n            this.position.x = value;\n\n        }\n\n    },\n\n    /**\n    * The vertical position of the DisplayObject, in pixels, relative to its parent.\n    * If you need the world position of the DisplayObject, use `DisplayObject.worldPosition` instead.\n    * @name PIXI.DisplayObject#y\n    * @property {number} y - The vertical position of the DisplayObject, in pixels, relative to its parent.\n    */\n    y: {\n\n        get: function ()\n        {\n\n            return this.position.y;\n\n        },\n\n        set: function (value)\n        {\n\n            this.position.y = value;\n\n        }\n\n    },\n\n    /**\n    * Indicates if this DisplayObject is visible, based on it, and all of its parents, `visible` property values.\n    * @name PIXI.DisplayObject#worldVisible\n    * @property {boolean} worldVisible - Indicates if this DisplayObject is visible, based on it, and all of its parents, `visible` property values.\n    */\n    worldVisible: {\n\n        get: function ()\n        {\n\n            if (!this.visible)\n            {\n                return false;\n            }\n            else\n            {\n                var item = this.parent;\n\n                if (!item)\n                {\n                    return this.visible;\n                }\n                else\n                {\n                    do\n                    {\n                        if (!item.visible)\n                        {\n                            return false;\n                        }\n\n                        item = item.parent;\n                    }\n                    while (item);\n\n                }\n\n                return true;\n            }\n\n        }\n\n    },\n\n    /**\n    * Sets a mask for this DisplayObject. A mask is an instance of a Graphics object.\n    * When applied it limits the visible area of this DisplayObject to the shape of the mask.\n    * Under a Canvas renderer it uses shape clipping. Under a WebGL renderer it uses a Stencil Buffer.\n    * To remove a mask, set this property to `null`.\n    *\n    * @name PIXI.DisplayObject#mask\n    * @property {Phaser.Graphics} mask - The mask applied to this DisplayObject. Set to `null` to remove an existing mask.\n    */\n    mask: {\n\n        get: function ()\n        {\n\n            return this._mask;\n\n        },\n\n        set: function (value)\n        {\n\n            if (this._mask)\n            {\n                this._mask.isMask = false;\n            }\n\n            this._mask = value;\n\n            if (value)\n            {\n                this._mask.isMask = true;\n            }\n\n        }\n\n    },\n\n    /**\n    * Sets the filters for this DisplayObject. This is a WebGL only feature, and is ignored by the Canvas\n    * Renderer. A filter is a shader applied to this DisplayObject. You can modify the placement of the filter\n    * using `DisplayObject.filterArea`.\n    *\n    * To remove filters, set this property to `null`.\n    *\n    * Note: You cannot have a filter set, and a MULTIPLY Blend Mode active, at the same time. Setting a\n    * filter will reset this DisplayObjects blend mode to NORMAL.\n    *\n    * @name PIXI.DisplayObject#filters\n    * @property {Array} filters - An Array of Phaser.Filter objects, or objects that extend them.\n    */\n    filters: {\n\n        get: function ()\n        {\n\n            return this._filters;\n\n        },\n\n        set: function (value)\n        {\n\n            if (Array.isArray(value))\n            {\n                //  Put all the passes in one place.\n                var passes = [];\n\n                for (var i = 0; i < value.length; i++)\n                {\n                    var filterPasses = value[i].passes;\n\n                    for (var j = 0; j < filterPasses.length; j++)\n                    {\n                        passes.push(filterPasses[j]);\n                    }\n                }\n\n                //  Needed any more?\n                this._filterBlock = { target: this, filterPasses: passes };\n            }\n\n            this._filters = value;\n\n            if (this.blendMode && this.blendMode === PIXI.blendModes.MULTIPLY)\n            {\n                this.blendMode = PIXI.blendModes.NORMAL;\n            }\n\n        }\n\n    },\n\n    /**\n    * Sets if this DisplayObject should be cached as a bitmap.\n    *\n    * When invoked it will take a snapshot of the DisplayObject, as it is at that moment, and store it\n    * in a RenderTexture. This is then used whenever this DisplayObject is rendered. It can provide a\n    * performance benefit for complex, but static, DisplayObjects. I.e. those with lots of children.\n    *\n    * Transparent areas adjoining the edges may be removed ({@link https://github.com/photonstorm/phaser-ce/issues/283 #283}).\n    *\n    * Cached Bitmaps do not track their parents. If you update a property of this DisplayObject, it will not\n    * re-generate the cached bitmap automatically. To do that you need to call `DisplayObject.updateCache`.\n    *\n    * To remove a cached bitmap, set this property to `null`.\n    *\n    * @name PIXI.DisplayObject#cacheAsBitmap\n    * @property {boolean} cacheAsBitmap - Cache this DisplayObject as a Bitmap. Set to `null` to remove an existing cached bitmap.\n    */\n    cacheAsBitmap: {\n\n        get: function ()\n        {\n\n            return this._cacheAsBitmap;\n\n        },\n\n        set: function (value)\n        {\n\n            if (this._cacheAsBitmap === value)\n            {\n                return;\n            }\n\n            if (value)\n            {\n                this._generateCachedSprite();\n            }\n            else\n            {\n                this._destroyCachedSprite();\n            }\n\n            this._cacheAsBitmap = value;\n\n        }\n\n    }\n\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A DisplayObjectContainer represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n * @class PIXI.DisplayObjectContainer\n * @extends PIXI.DisplayObject\n * @constructor\n */\nPIXI.DisplayObjectContainer = function ()\n{\n\n    PIXI.DisplayObject.call(this);\n\n    /**\n     * [read-only] The array of children of this container.\n     *\n     * @property children\n     * @type Array(DisplayObject)\n     * @readOnly\n     */\n    this.children = [];\n\n    /**\n    * If `ignoreChildInput`  is `false` it will allow this objects _children_ to be considered as valid for Input events.\n    *\n    * If this property is `true` then the children will _not_ be considered as valid for Input events.\n    *\n    * Note that this property isn't recursive: only immediate children are influenced, it doesn't scan further down.\n    * @property {boolean} ignoreChildInput\n    * @default\n    */\n    this.ignoreChildInput = false;\n\n};\n\nPIXI.DisplayObjectContainer.prototype = Object.create(PIXI.DisplayObject.prototype);\nPIXI.DisplayObjectContainer.prototype.constructor = PIXI.DisplayObjectContainer;\n\n/**\n * Adds a child to the container.\n *\n * @method PIXI.DisplayObjectContainer#addChild\n * @param child {DisplayObject} The DisplayObject to add to the container\n * @return {DisplayObject} The child that was added.\n */\nPIXI.DisplayObjectContainer.prototype.addChild = function (child)\n{\n\n    return this.addChildAt(child, this.children.length);\n\n};\n\n/**\n * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n *\n * @method PIXI.DisplayObjectContainer#addChildAt\n * @param child {DisplayObject} The child to add\n * @param index {Number} The index to place the child in\n * @return {DisplayObject} The child that was added.\n */\nPIXI.DisplayObjectContainer.prototype.addChildAt = function (child, index)\n{\n\n    if (index >= 0 && index <= this.children.length)\n    {\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n\n        this.children.splice(index, 0, child);\n\n        return child;\n    }\n    else\n    {\n        throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);\n    }\n\n};\n\n/**\n * Swaps the position of 2 Display Objects within this container.\n *\n * @method PIXI.DisplayObjectContainer#swapChildren\n * @param child {DisplayObject}\n * @param child2 {DisplayObject}\n */\nPIXI.DisplayObjectContainer.prototype.swapChildren = function (child, child2)\n{\n\n    if (child === child2)\n    {\n        return;\n    }\n\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n\n    if (index1 < 0 || index2 < 0)\n    {\n        throw new Error('swapChildren: Both the supplied DisplayObjects must be a child of the caller.');\n    }\n\n    this.children[index1] = child2;\n    this.children[index2] = child;\n\n};\n\n/**\n * Returns the index position of a child DisplayObject instance\n *\n * @method PIXI.DisplayObjectContainer#getChildIndex\n * @param child {DisplayObject} The DisplayObject instance to identify\n * @return {Number} The index position of the child display object to identify\n */\nPIXI.DisplayObjectContainer.prototype.getChildIndex = function (child)\n{\n\n    var index = this.children.indexOf(child);\n\n    if (index === -1)\n    {\n        throw new Error('The supplied DisplayObject must be a child of the caller');\n    }\n\n    return index;\n\n};\n\n/**\n * Changes the position of an existing child in the display object container\n *\n * @method PIXI.DisplayObjectContainer#setChildIndex\n * @param child {DisplayObject} The child DisplayObject instance for which you want to change the index number\n * @param index {Number} The resulting index number for the child display object\n */\nPIXI.DisplayObjectContainer.prototype.setChildIndex = function (child, index)\n{\n\n    if (index < 0 || index >= this.children.length)\n    {\n        throw new Error('The supplied index is out of bounds');\n    }\n\n    var currentIndex = this.getChildIndex(child);\n\n    this.children.splice(currentIndex, 1); // remove from old position\n    this.children.splice(index, 0, child); // add at new position\n\n};\n\n/**\n * Returns the child at the specified index\n *\n * @method PIXI.DisplayObjectContainer#getChildAt\n * @param index {Number} The index to get the child from\n * @return {DisplayObject} The child at the given index, if any.\n */\nPIXI.DisplayObjectContainer.prototype.getChildAt = function (index)\n{\n\n    if (index < 0 || index >= this.children.length)\n    {\n        throw new Error('getChildAt: Supplied index ' + index + ' does not exist in the child list, or the supplied DisplayObject must be a child of the caller');\n    }\n\n    return this.children[index];\n\n};\n\n/**\n * Removes a child from the container.\n *\n * @method PIXI.DisplayObjectContainer#removeChild\n * @param child {DisplayObject} The DisplayObject to remove\n * @return {DisplayObject} The child that was removed.\n */\nPIXI.DisplayObjectContainer.prototype.removeChild = function (child)\n{\n\n    var index = this.children.indexOf(child);\n\n    if (index === -1)\n    {\n        return;\n    }\n\n    return this.removeChildAt(index);\n\n};\n\n/**\n * Removes a child from the specified index position.\n *\n * @method PIXI.DisplayObjectContainer#removeChildAt\n * @param index {Number} The index to get the child from\n * @return {DisplayObject} The child that was removed.\n */\nPIXI.DisplayObjectContainer.prototype.removeChildAt = function (index)\n{\n\n    var child = this.getChildAt(index);\n\n    if (child)\n    {\n        child.parent = undefined;\n\n        this.children.splice(index, 1);\n    }\n\n    return child;\n\n};\n\nPIXI.DisplayObjectContainer.prototype.bringChildToTop = function (child)\n{\n\n    if (child.parent !== this)\n    {\n        return;\n    }\n\n    return this.setChildIndex(child, this.children.length - 1);\n\n};\n\nPIXI.DisplayObjectContainer.prototype.sendChildToBack = function (child)\n{\n\n    if (child.parent !== this)\n    {\n        return;\n    }\n\n    return this.setChildIndex(child, 0);\n\n};\n\n/**\n* Removes all children from this container that are within the begin and end indexes.\n*\n* @method PIXI.DisplayObjectContainer#removeChildren\n* @param beginIndex {Number} The beginning position. Default value is 0.\n* @param endIndex {Number} The ending position. Default value is size of the container.\n*/\nPIXI.DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex)\n{\n\n    if (beginIndex === undefined) { beginIndex = 0; }\n    if (endIndex === undefined) { endIndex = this.children.length; }\n\n    var range = endIndex - beginIndex;\n\n    if (range > 0 && range <= endIndex)\n    {\n        var removed = this.children.splice(beginIndex, range);\n\n        for (var i = 0; i < removed.length; i++)\n        {\n            var child = removed[i];\n            child.parent = undefined;\n        }\n\n        return removed;\n    }\n    else if (range === 0 && this.children.length === 0)\n    {\n        return [];\n    }\n    else\n    {\n        throw new Error('removeChildren: Range Error, numeric values are outside the acceptable range');\n    }\n\n};\n\n/*\n * Updates the transform on all children of this container for rendering\n *\n * @method PIXI.DisplayObjectContainer#updateTransform\n * @private\n */\nPIXI.DisplayObjectContainer.prototype.updateTransform = function ()\n{\n\n    if (!this.visible)\n    {\n        return;\n    }\n\n    this.displayObjectUpdateTransform();\n\n    if (this._cacheAsBitmap)\n    {\n        return;\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n};\n\n// performance increase to avoid using call.. (10x faster)\nPIXI.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = PIXI.DisplayObjectContainer.prototype.updateTransform;\n\n/**\n * Retrieves the global bounds of the displayObjectContainer as a rectangle. The bounds calculation takes all visible children into consideration.\n *\n * @method PIXI.DisplayObjectContainer#getBounds\n * @param {PIXI.DisplayObject|Phaser.Matrix} [targetCoordinateSpace] Returns a rectangle that defines the area of the display object relative to the coordinate system of the targetCoordinateSpace object.\n * @return {Rectangle} The rectangular bounding area\n */\nPIXI.DisplayObjectContainer.prototype.getBounds = function (targetCoordinateSpace)\n{\n\n    var isTargetCoordinateSpaceDisplayObject = (targetCoordinateSpace && targetCoordinateSpace instanceof PIXI.DisplayObject);\n    var isTargetCoordinateSpaceThisOrParent = true;\n\n    if (!isTargetCoordinateSpaceDisplayObject)\n    {\n        targetCoordinateSpace = this;\n    }\n    else if (targetCoordinateSpace instanceof PIXI.DisplayObjectContainer)\n    {\n        isTargetCoordinateSpaceThisOrParent = targetCoordinateSpace.contains(this);\n    }\n    else\n    {\n        isTargetCoordinateSpaceThisOrParent = false;\n    }\n\n    var i;\n\n    if (isTargetCoordinateSpaceDisplayObject)\n    {\n        var matrixCache = targetCoordinateSpace.worldTransform;\n\n        targetCoordinateSpace.worldTransform = Phaser.identityMatrix;\n\n        for (i = 0; i < targetCoordinateSpace.children.length; i++)\n        {\n            targetCoordinateSpace.children[i].updateTransform();\n        }\n    }\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var childBounds;\n    var childMaxX;\n    var childMaxY;\n\n    var childVisible = false;\n\n    for (i = 0; i < this.children.length; i++)\n    {\n        var child = this.children[i];\n\n        if (!child.visible)\n        {\n            continue;\n        }\n\n        childVisible = true;\n\n        childBounds = this.children[i].getBounds();\n\n        minX = (minX < childBounds.x) ? minX : childBounds.x;\n        minY = (minY < childBounds.y) ? minY : childBounds.y;\n\n        childMaxX = childBounds.width + childBounds.x;\n        childMaxY = childBounds.height + childBounds.y;\n\n        maxX = (maxX > childMaxX) ? maxX : childMaxX;\n        maxY = (maxY > childMaxY) ? maxY : childMaxY;\n    }\n\n    var bounds = this._bounds;\n\n    if (!childVisible)\n    {\n        bounds = new PIXI.Rectangle();\n\n        var w0 = bounds.x;\n        var w1 = bounds.width + bounds.x;\n\n        var h0 = bounds.y;\n        var h1 = bounds.height + bounds.y;\n\n        var worldTransform = this.worldTransform;\n\n        var a = worldTransform.a;\n        var b = worldTransform.b;\n        var c = worldTransform.c;\n        var d = worldTransform.d;\n        var tx = worldTransform.tx;\n        var ty = worldTransform.ty;\n\n        var x1 = a * w1 + c * h1 + tx;\n        var y1 = d * h1 + b * w1 + ty;\n\n        var x2 = a * w0 + c * h1 + tx;\n        var y2 = d * h1 + b * w0 + ty;\n\n        var x3 = a * w0 + c * h0 + tx;\n        var y3 = d * h0 + b * w0 + ty;\n\n        var x4 = a * w1 + c * h0 + tx;\n        var y4 = d * h0 + b * w1 + ty;\n\n        maxX = x1;\n        maxY = y1;\n\n        minX = x1;\n        minY = y1;\n\n        minX = x2 < minX ? x2 : minX;\n        minX = x3 < minX ? x3 : minX;\n        minX = x4 < minX ? x4 : minX;\n\n        minY = y2 < minY ? y2 : minY;\n        minY = y3 < minY ? y3 : minY;\n        minY = y4 < minY ? y4 : minY;\n\n        maxX = x2 > maxX ? x2 : maxX;\n        maxX = x3 > maxX ? x3 : maxX;\n        maxX = x4 > maxX ? x4 : maxX;\n\n        maxY = y2 > maxY ? y2 : maxY;\n        maxY = y3 > maxY ? y3 : maxY;\n        maxY = y4 > maxY ? y4 : maxY;\n    }\n\n    bounds.x = minX;\n    bounds.y = minY;\n    bounds.width = maxX - minX;\n    bounds.height = maxY - minY;\n\n    if (isTargetCoordinateSpaceDisplayObject)\n    {\n        targetCoordinateSpace.worldTransform = matrixCache;\n\n        for (i = 0; i < targetCoordinateSpace.children.length; i++)\n        {\n            targetCoordinateSpace.children[i].updateTransform();\n        }\n    }\n\n    if (!isTargetCoordinateSpaceThisOrParent)\n    {\n        var targetCoordinateSpaceBounds = targetCoordinateSpace.getBounds();\n\n        bounds.x -= targetCoordinateSpaceBounds.x;\n        bounds.y -= targetCoordinateSpaceBounds.y;\n    }\n\n    return bounds;\n\n};\n\n/**\n * Retrieves the non-global local bounds of the displayObjectContainer as a rectangle without any transformations. The calculation takes all visible children into consideration.\n *\n * @method PIXI.DisplayObjectContainer#getLocalBounds\n * @return {Rectangle} The rectangular bounding area\n */\nPIXI.DisplayObjectContainer.prototype.getLocalBounds = function ()\n{\n\n    return this.getBounds(this);\n\n};\n\n/**\n* Determines whether the specified display object is a child of the DisplayObjectContainer instance or the instance itself.\n*\n* @method PIXI.DisplayObjectContainer#contains\n* @param {DisplayObject} child\n* @returns {boolean}\n*/\nPIXI.DisplayObjectContainer.prototype.contains = function (child)\n{\n\n    if (!child)\n    {\n        return false;\n    }\n    else if (child === this)\n    {\n        return true;\n    }\n    else\n    {\n        return this.contains(child.parent);\n    }\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method PIXI.DisplayObjectContainer#_renderWebGL\n* @param renderSession {RenderSession}\n* @private\n*/\nPIXI.DisplayObjectContainer.prototype._renderWebGL = function (renderSession)\n{\n\n    if (!this.visible || this.alpha <= 0)\n    {\n        return;\n    }\n\n    if (this._cacheAsBitmap)\n    {\n        this._renderCachedSprite(renderSession);\n        return;\n    }\n\n    var i;\n\n    if (this._mask || this._filters)\n    {\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (this._filters)\n        {\n            renderSession.spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        if (this._mask)\n        {\n            renderSession.spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            renderSession.spriteBatch.start();\n        }\n\n        // simple render children!\n        for (i = 0; i < this.children.length; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        renderSession.spriteBatch.stop();\n\n        if (this._mask) { renderSession.maskManager.popMask(this._mask, renderSession); }\n        if (this._filters) { renderSession.filterManager.popFilter(); }\n\n        renderSession.spriteBatch.start();\n    }\n    else\n    {\n        // simple render children!\n        for (i = 0; i < this.children.length; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n    }\n\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method PIXI.DisplayObjectContainer#_renderCanvas\n* @param renderSession {RenderSession}\n* @private\n*/\nPIXI.DisplayObjectContainer.prototype._renderCanvas = function (renderSession)\n{\n\n    if (this.visible === false || this.alpha === 0)\n    {\n        return;\n    }\n\n    if (this._cacheAsBitmap)\n    {\n        this._renderCachedSprite(renderSession);\n        return;\n    }\n\n    if (this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, renderSession);\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i]._renderCanvas(renderSession);\n    }\n\n    if (this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession);\n    }\n\n};\n\n/**\n * The width of the displayObjectContainer, setting this will actually modify the scale to achieve the value set\n *\n * @name PIXI.DisplayObjectContainer#width\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'width', {\n\n    get: function ()\n    {\n        return this.getLocalBounds().width * this.scale.x;\n    },\n\n    set: function (value)\n    {\n\n        var width = this.getLocalBounds().width;\n\n        if (width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n\n        this._width = value;\n    }\n});\n\n/**\n * The height of the displayObjectContainer, setting this will actually modify the scale to achieve the value set\n *\n * @name PIXI.DisplayObjectContainer#height\n * @type Number\n */\nObject.defineProperty(PIXI.DisplayObjectContainer.prototype, 'height', {\n\n    get: function ()\n    {\n        return this.getLocalBounds().height * this.scale.y;\n    },\n\n    set: function (value)\n    {\n\n        var height = this.getLocalBounds().height;\n\n        if (height !== 0)\n        {\n            this.scale.y = value / height;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n\n});\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n *\n * @class PIXI.Sprite\n * @extends PIXI.DisplayObjectContainer\n * @constructor\n * @param texture {Texture} The texture for this sprite\n */\nPIXI.Sprite = function (texture)\n{\n\n    PIXI.DisplayObjectContainer.call(this);\n\n    /**\n     * The anchor sets the origin point of the texture.\n     * The default (0, 0) is the top left.\n     * (0.5, 0.5) is the center.\n     * (1, 1) is the bottom right.\n     *\n     * You can modify the default values in PIXI.Sprite.defaultAnchor.\n     *\n     * @property anchor\n     * @type Point\n     */\n    this.anchor = new PIXI.Point(PIXI.Sprite.defaultAnchor.x, PIXI.Sprite.defaultAnchor.y);\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @property texture\n     * @type Texture\n     */\n    this.texture = texture || PIXI.Texture.emptyTexture;\n\n    /**\n     * The width of the sprite (this is initially set by the texture)\n     *\n     * @property _width\n     * @type Number\n     * @private\n     */\n    this._width = 0;\n\n    /**\n     * The height of the sprite (this is initially set by the texture)\n     *\n     * @property _height\n     * @type Number\n     * @private\n     */\n    this._height = 0;\n\n    /**\n     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF (Phaser.Color.WHITE) will remove any tint effect.\n     *\n     * @property tint\n     * @type Number\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n\n    /**\n     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @property cachedTint\n     * @private\n     * @type Number\n     * @default -1\n     */\n    this.cachedTint = -1;\n\n    /**\n     * A canvas that contains the tinted version of the Sprite (in Canvas mode, WebGL doesn't populate this)\n     *\n     * @property tintedTexture\n     * @type Canvas\n     * @default null\n     */\n    this.tintedTexture = null;\n\n    /**\n     * The blend mode to be applied to the sprite. Set to PIXI.blendModes.NORMAL to remove any blend mode.\n     *\n     * Warning: You cannot have a blend mode and a filter active on the same Sprite. Doing so will render the sprite invisible.\n     *\n     * @property blendMode\n     * @type Number\n     * @default PIXI.blendModes.NORMAL;\n     */\n    this.blendMode = PIXI.blendModes.NORMAL;\n\n    /**\n     * The shader that will be used to render this Sprite.\n     * Set to null to remove a current shader.\n     *\n     * @property shader\n     * @type Phaser.Filter\n     * @default null\n     */\n    this.shader = null;\n\n    /**\n    * Controls if this Sprite is processed by the core Phaser game loops and Group loops (except {@link Phaser.Group#update}).\n    *\n    * @property exists\n    * @type Boolean\n    * @default true\n    */\n    this.exists = true;\n\n    if (this.texture.baseTexture.hasLoaded)\n    {\n        this.onTextureUpdate();\n    }\n\n    this.renderable = true;\n\n};\n\n/**\n * @property PIXI.Sprite.defaultAnchor - A Point-like object.\n * @type {{x: number, y: number}}\n * @default\n */\nPIXI.Sprite.defaultAnchor = {x: 0, y: 0};\n\n// constructor\nPIXI.Sprite.prototype = Object.create(PIXI.DisplayObjectContainer.prototype);\nPIXI.Sprite.prototype.constructor = PIXI.Sprite;\n\n/**\n * The width of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property width\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'width', {\n\n    get: function ()\n    {\n        return this.scale.x * this.texture.frame.width;\n    },\n\n    set: function (value)\n    {\n        this.scale.x = value / this.texture.frame.width;\n        this._width = value;\n    }\n\n});\n\n/**\n * The height of the sprite, setting this will actually modify the scale to achieve the value set\n *\n * @property height\n * @type Number\n */\nObject.defineProperty(PIXI.Sprite.prototype, 'height', {\n\n    get: function ()\n    {\n        return this.scale.y * this.texture.frame.height;\n    },\n\n    set: function (value)\n    {\n        this.scale.y = value / this.texture.frame.height;\n        this._height = value;\n    }\n\n});\n\n/**\n * Sets the texture of the sprite. Be warned that this doesn't remove or destroy the previous\n * texture this Sprite was using.\n *\n * @method PIXI.Sprite#setTexture\n * @param texture {Texture} The PIXI texture that is displayed by the sprite\n * @param [destroy=false] {boolean} Call Texture.destroy on the current texture before replacing it with the new one?\n */\nPIXI.Sprite.prototype.setTexture = function (texture, destroyBase)\n{\n    if (destroyBase)\n    {\n        this.texture.baseTexture.destroy();\n    }\n\n    //  Over-ridden by loadTexture as needed\n    this.texture.baseTexture.skipRender = false;\n    this.texture = texture;\n    this.texture.valid = true;\n    this.cachedTint = -1;\n};\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @method PIXI.Sprite#onTextureUpdate\n * @param event\n * @private\n */\nPIXI.Sprite.prototype.onTextureUpdate = function ()\n{\n    // so if _width is 0 then width was not set..\n    if (this._width) { this.scale.x = this._width / this.texture.frame.width; }\n    if (this._height) { this.scale.y = this._height / this.texture.frame.height; }\n};\n\n/**\n* Returns the bounds of the Sprite as a rectangle.\n* The bounds calculation takes the worldTransform into account.\n*\n* The worldTransform was calculated during the last render pass and is not updated when you call this method.\n* If this Sprite was just created and has never been rendered, you can call `updateTransform` on the Sprite itself.\n* If any of the Sprite's ancestors have been positioned, scaled, or rotated since the last render pass,\n* those changes have not yet have been applied to this Sprite's worldTransform. Call `updateTransform`\n* on the root-most (highest) ancestor that was changed.\n*\n* @method PIXI.Sprite#getBounds\n* @param matrix {Matrix} the transformation matrix of the sprite\n* @return {Rectangle} the framing rectangle\n*/\nPIXI.Sprite.prototype.getBounds = function (matrix)\n{\n    var width = this.texture.frame.width;\n    var height = this.texture.frame.height;\n\n    var w0 = width * (1 - this.anchor.x);\n    var w1 = width * -this.anchor.x;\n\n    var h0 = height * (1 - this.anchor.y);\n    var h1 = height * -this.anchor.y;\n\n    var worldTransform = matrix || this.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var maxX = -Infinity;\n    var maxY = -Infinity;\n\n    var minX = Infinity;\n    var minY = Infinity;\n\n    if (b === 0 && c === 0)\n    {\n        // scale may be negative!\n        if (a < 0)\n        {\n            a *= -1;\n            var temp = w0;\n            w0 = -w1;\n            w1 = -temp;\n        }\n\n        if (d < 0)\n        {\n            d *= -1;\n            var temp = h0;\n            h0 = -h1;\n            h1 = -temp;\n        }\n\n        // this means there is no rotation going on right? RIGHT?\n        // if thats the case then we can avoid checking the bound values! yay\n        minX = a * w1 + tx;\n        maxX = a * w0 + tx;\n        minY = d * h1 + ty;\n        maxY = d * h0 + ty;\n    }\n    else\n    {\n        var x1 = a * w1 + c * h1 + tx;\n        var y1 = d * h1 + b * w1 + ty;\n\n        var x2 = a * w0 + c * h1 + tx;\n        var y2 = d * h1 + b * w0 + ty;\n\n        var x3 = a * w0 + c * h0 + tx;\n        var y3 = d * h0 + b * w0 + ty;\n\n        var x4 = a * w1 + c * h0 + tx;\n        var y4 = d * h0 + b * w1 + ty;\n\n        minX = x1 < minX ? x1 : minX;\n        minX = x2 < minX ? x2 : minX;\n        minX = x3 < minX ? x3 : minX;\n        minX = x4 < minX ? x4 : minX;\n\n        minY = y1 < minY ? y1 : minY;\n        minY = y2 < minY ? y2 : minY;\n        minY = y3 < minY ? y3 : minY;\n        minY = y4 < minY ? y4 : minY;\n\n        maxX = x1 > maxX ? x1 : maxX;\n        maxX = x2 > maxX ? x2 : maxX;\n        maxX = x3 > maxX ? x3 : maxX;\n        maxX = x4 > maxX ? x4 : maxX;\n\n        maxY = y1 > maxY ? y1 : maxY;\n        maxY = y2 > maxY ? y2 : maxY;\n        maxY = y3 > maxY ? y3 : maxY;\n        maxY = y4 > maxY ? y4 : maxY;\n    }\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    this._currentBounds = bounds;\n\n    return bounds;\n};\n\n/**\n * Retrieves the non-global local bounds of the Sprite as a rectangle. The calculation takes all visible children into consideration.\n *\n * @method PIXI.Sprite#getLocalBounds\n * @return {Rectangle} The rectangular bounding area\n */\nPIXI.Sprite.prototype.getLocalBounds = function ()\n{\n\n    var matrixCache = this.worldTransform;\n\n    this.worldTransform = Phaser.identityMatrix;\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n    var bounds = this.getBounds();\n\n    this.worldTransform = matrixCache;\n\n    for (i = 0; i < this.children.length; i++)\n    {\n        this.children[i].updateTransform();\n    }\n\n    return bounds;\n\n};\n\n/**\n* Renders the object using the WebGL renderer\n*\n* @method PIXI.Sprite#_renderWebGL\n* @param renderSession {RenderSession}\n* @param {Matrix} [matrix] - Optional matrix. If provided the Display Object will be rendered using this matrix, otherwise it will use its worldTransform.\n* @private\n*/\nPIXI.Sprite.prototype._renderWebGL = function (renderSession, matrix)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.alpha <= 0 || !this.renderable) { return; }\n\n    //  They provided an alternative rendering matrix, so use it\n    var wt = this.worldTransform;\n\n    if (matrix)\n    {\n        wt = matrix;\n    }\n\n    //  A quick check to see if this element has a mask or a filter.\n    if (this._mask || this._filters)\n    {\n        var spriteBatch = renderSession.spriteBatch;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (this._filters)\n        {\n            spriteBatch.flush();\n            renderSession.filterManager.pushFilter(this._filterBlock);\n        }\n\n        if (this._mask)\n        {\n            spriteBatch.stop();\n            renderSession.maskManager.pushMask(this.mask, renderSession);\n            spriteBatch.start();\n        }\n\n        // add this sprite to the batch\n        spriteBatch.render(this);\n\n        // now loop through the children and make sure they get rendered\n        for (var i = 0; i < this.children.length; i++)\n        {\n            this.children[i]._renderWebGL(renderSession);\n        }\n\n        // time to stop the sprite batch as either a mask element or a filter draw will happen next\n        spriteBatch.stop();\n\n        if (this._mask) { renderSession.maskManager.popMask(this._mask, renderSession); }\n        if (this._filters) { renderSession.filterManager.popFilter(); }\n\n        spriteBatch.start();\n    }\n    else\n    {\n        renderSession.spriteBatch.render(this);\n\n        //  Render children!\n        for (var i = 0; i < this.children.length; i++)\n        {\n            this.children[i]._renderWebGL(renderSession, wt);\n        }\n\n    }\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @method PIXI.Sprite#_renderCanvas\n* @param renderSession {RenderSession}\n* @param {Matrix} [matrix] - Optional matrix. If provided the Display Object will be rendered using this matrix, otherwise it will use its worldTransform.\n* @private\n*/\nPIXI.Sprite.prototype._renderCanvas = function (renderSession, matrix)\n{\n    // If the sprite is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.alpha === 0 || !this.renderable || this.texture.crop.width < 1 || this.texture.crop.height < 1)\n    {\n        return;\n    }\n\n    var wt = this.worldTransform;\n\n    //  If they provided an alternative rendering matrix then use it\n    if (matrix)\n    {\n        wt = matrix;\n    }\n\n    if (this.blendMode !== renderSession.currentBlendMode)\n    {\n        renderSession.currentBlendMode = this.blendMode;\n        renderSession.context.globalCompositeOperation = PIXI.blendModesCanvas[renderSession.currentBlendMode];\n    }\n\n    if (this._mask)\n    {\n        renderSession.maskManager.pushMask(this._mask, renderSession);\n    }\n\n    //  Ignore null sources\n    if (!this.texture.valid)\n    {\n        //  Update the children and leave\n        for (var i = 0; i < this.children.length; i++)\n        {\n            this.children[i]._renderCanvas(renderSession);\n        }\n\n        if (this._mask)\n        {\n            renderSession.maskManager.popMask(renderSession);\n        }\n\n        return;\n    }\n\n    var resolution = this.texture.baseTexture.resolution / renderSession.resolution;\n\n    renderSession.context.globalAlpha = this.worldAlpha;\n\n    //  If smoothingEnabled is supported and we need to change the smoothing property for this texture\n    if (renderSession.smoothProperty && renderSession.scaleMode !== this.texture.baseTexture.scaleMode)\n    {\n        renderSession.scaleMode = this.texture.baseTexture.scaleMode;\n        renderSession.context[renderSession.smoothProperty] = (renderSession.scaleMode === PIXI.scaleModes.LINEAR);\n    }\n\n    //  If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions\n    var dx = (this.texture.trim) ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width;\n    var dy = (this.texture.trim) ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height;\n\n    var tx = (wt.tx * renderSession.resolution) + renderSession.shakeX;\n    var ty = (wt.ty * renderSession.resolution) + renderSession.shakeY;\n\n    var cw = this.texture.crop.width;\n    var ch = this.texture.crop.height;\n\n    if (this.texture.rotated)\n    {\n        var a = wt.a;\n        var b = wt.b;\n        var c = wt.c;\n        var d = wt.d;\n        var e = cw;\n\n        // Offset before rotating\n        tx = wt.c * ch + tx;\n        ty = wt.d * ch + ty;\n\n        // Rotate matrix by 90 degrees\n        // We use precalculated values for sine and cosine of rad(90)\n        wt.a = a * 6.123233995736766e-17 + -c;\n        wt.b = b * 6.123233995736766e-17 + -d;\n        wt.c = a + c * 6.123233995736766e-17;\n        wt.d = b + d * 6.123233995736766e-17;\n\n        // Update cropping dimensions.\n        cw = ch;\n        ch = e;\n    }\n\n    //  Allow for pixel rounding\n    if (renderSession.roundPixels)\n    {\n        renderSession.context.setTransform(wt.a, wt.b, wt.c, wt.d, tx | 0, ty | 0);\n        dx |= 0;\n        dy |= 0;\n    }\n    else\n    {\n        renderSession.context.setTransform(wt.a, wt.b, wt.c, wt.d, tx, ty);\n    }\n\n    dx /= resolution;\n    dy /= resolution;\n\n    cw |= 0;\n    ch |= 0;\n\n    if (!cw || !ch)\n    {\n        return;\n    }\n\n    if (this.tint !== 0xFFFFFF)\n    {\n        if (this.texture.requiresReTint || this.cachedTint !== this.tint)\n        {\n            this.tintedTexture = PIXI.CanvasTinter.getTintedTexture(this, this.tint);\n\n            this.cachedTint = this.tint;\n            this.texture.requiresReTint = false;\n        }\n\n        renderSession.context.drawImage(this.tintedTexture, 0, 0, cw, ch, dx, dy, cw / resolution, ch / resolution);\n    }\n    else\n    {\n        var cx = this.texture.crop.x;\n        var cy = this.texture.crop.y;\n\n        renderSession.context.drawImage(this.texture.baseTexture.source, cx, cy, cw, ch, dx, dy, cw / resolution, ch / resolution);\n    }\n\n    for (var i = 0; i < this.children.length; i++)\n    {\n        this.children[i]._renderCanvas(renderSession);\n    }\n\n    if (this._mask)\n    {\n        renderSession.maskManager.popMask(renderSession);\n    }\n\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @method PIXI.initDefaultShaders\n* @static\n* @private\n*/\nPIXI.initDefaultShaders = function ()\n{\n};\n\n/**\n* @method PIXI.CompileVertexShader\n* @static\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param shaderSrc {Array}\n* @return {Any}\n*/\nPIXI.CompileVertexShader = function (gl, shaderSrc)\n{\n    return PIXI._CompileShader(gl, shaderSrc, gl.VERTEX_SHADER);\n};\n\n/**\n* @method PIXI.CompileFragmentShader\n* @static\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param shaderSrc {Array}\n* @return {Any}\n*/\nPIXI.CompileFragmentShader = function (gl, shaderSrc)\n{\n    return PIXI._CompileShader(gl, shaderSrc, gl.FRAGMENT_SHADER);\n};\n\n/**\n* @method PIXI._CompileShader\n* @static\n* @private\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param shaderSrc {Array}\n* @param shaderType {Number}\n* @return {Any}\n*/\nPIXI._CompileShader = function (gl, shaderSrc, shaderType)\n{\n    var src = shaderSrc;\n\n    if (Array.isArray(shaderSrc))\n    {\n        src = shaderSrc.join('\\n');\n    }\n\n    var shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n    {\n        window.console.log(gl.getShaderInfoLog(shader));\n        return null;\n    }\n\n    return shader;\n};\n\n/**\n* @method PIXI.compileProgram\n* @static\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param vertexSrc {Array}\n* @param fragmentSrc {Array}\n* @return {Any}\n*/\nPIXI.compileProgram = function (gl, vertexSrc, fragmentSrc)\n{\n    var fragmentShader = PIXI.CompileFragmentShader(gl, fragmentSrc);\n    var vertexShader = PIXI.CompileVertexShader(gl, vertexSrc);\n\n    var shaderProgram = gl.createProgram();\n\n    gl.attachShader(shaderProgram, vertexShader);\n    gl.attachShader(shaderProgram, fragmentShader);\n    gl.linkProgram(shaderProgram);\n\n    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))\n    {\n        window.console.log(gl.getProgramInfoLog(shaderProgram));\n        window.console.log('Could not initialise shaders');\n    }\n\n    return shaderProgram;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n * @author Richard Davey http://www.photonstorm.com @photonstorm\n */\n\n/**\n* @class PIXI.PixiShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PixiShader = function (gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = Phaser._UID++;\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type Any\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = null;\n\n    /**\n     * A local texture counter for multi-texture shaders.\n     * @property textureCount\n     * @type Number\n     */\n    this.textureCount = 0;\n\n    /**\n     * A local flag\n     * @property firstRun\n     * @type Boolean\n     * @private\n     */\n    this.firstRun = true;\n\n    /**\n     * A dirty flag\n     * @property dirty\n     * @type Boolean\n     */\n    this.dirty = true;\n\n    /**\n     * Uniform attributes cache.\n     * @property attributes\n     * @type Array\n     * @private\n     */\n    this.attributes = [];\n\n    this.init();\n};\n\nPIXI.PixiShader.prototype.constructor = PIXI.PixiShader;\n\nPIXI.PixiShader.prototype.initMultitexShader = function ()\n{\n    var gl = this.gl;\n    this.MAX_TEXTURES = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    var dynamicIfs = '\\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\\n';\n    for (var index = 1; index < this.MAX_TEXTURES; ++index)\n    {\n        dynamicIfs += '\\tif (vTextureIndex == ' +\n                    index + '.0) {gl_FragColor = texture2D(uSamplerArray[' +\n                    index + '], vTextureCoord) * vColor;return;}\\n';\n    }\n    this.fragmentSrc = [\n        '// PixiShader Fragment Shader.',\n        'precision lowp float;',\n        'bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }',\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n        'varying float vTextureIndex;',\n        'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + '];',\n\n        // Blue color means that you are trying to bound\n        // a texture out of the limits of the hardware.\n        'const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);',\n\n        // If you get a red color means you are out of memory\n        // or in some way corrupted the vertex buffer.\n        'const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);',\n        'void main(void) {',\n        dynamicIfs,\n        '   if(vTextureIndex >= ' + this.MAX_TEXTURES + '.0) { gl_FragColor = BLUE;return;}',\n        '   if(isnan(vTextureIndex)) { gl_FragColor = RED;return;}',\n        '}'\n    ];\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);\n\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    // this.uSampler = gl.getUniformLocation(program, 'uSampler');\n    this.uSamplerArray = gl.getUniformLocation(program, 'uSamplerArray[0]');\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n    this.aTextureIndex = gl.getAttribLocation(program, 'aTextureIndex');\n\n    var indices = [];\n\n    // HACK: we bind an empty texture to avoid WebGL warning spam.\n    var tempTexture = gl.createTexture();\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, tempTexture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, null);\n    for (var i = 0; i < this.MAX_TEXTURES; ++i)\n    {\n        gl.activeTexture(gl.TEXTURE0 + i);\n        gl.bindTexture(gl.TEXTURE_2D, tempTexture);\n        indices.push(i);\n    }\n    gl.activeTexture(gl.TEXTURE0);\n    gl.uniform1iv(this.uSamplerArray, indices);\n\n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its something to do with the current state of the gl context.\n    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if(this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [ this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex ];\n\n    // End worst hack eva //\n\n    // add those custom shaders!\n    for (var key in this.uniforms)\n    {\n        // get the uniform locations..\n        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);\n    }\n\n    this.initUniforms();\n\n    this.program = program;\n};\n\nPIXI.PixiShader.prototype.initDefaultShader = function ()\n{\n\n    if (this.fragmentSrc === null)\n    {\n        this.fragmentSrc = [\n            'precision lowp float;',\n            'varying vec2 vTextureCoord;',\n            'varying vec4 vColor;',\n            'varying float vTextureIndex;',\n            'uniform sampler2D uSampler;',\n            'void main(void) {',\n            '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;',\n            '}'\n        ];\n    }\n\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc || PIXI.PixiShader.defaultVertexSrc, this.fragmentSrc);\n\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = gl.getUniformLocation(program, 'uSampler');\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n    this.aTextureIndex = gl.getAttribLocation(program, 'aTextureIndex');\n\n\n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its something to do with the current state of the gl context.\n    // I'm convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if(this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [ this.aVertexPosition, this.aTextureCoord, this.colorAttribute, this.aTextureIndex ];\n\n    // End worst hack eva //\n\n    // add those custom shaders!\n    for (var key in this.uniforms)\n    {\n        // get the uniform locations..\n        this.uniforms[key].uniformLocation = gl.getUniformLocation(program, key);\n    }\n\n    this.initUniforms();\n\n    this.program = program;\n};\n\n/**\n* Initialises the shader.\n*\n* @method PIXI.PixiShader#init\n*/\nPIXI.PixiShader.prototype.init = function (usingFilter)\n{\n    if (PIXI._enableMultiTextureToggle && !usingFilter)\n    {\n        this.initMultitexShader();\n    }\n    else\n    {\n        this.initDefaultShader();\n    }\n};\n\n/**\n* Initialises the shader uniform values.\n*\n* Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\n* http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n*\n* @method PIXI.PixiShader#initUniforms\n*/\nPIXI.PixiShader.prototype.initUniforms = function ()\n{\n    this.textureCount = 1;\n    var gl = this.gl;\n    var uniform;\n\n    for (var key in this.uniforms)\n    {\n        uniform = this.uniforms[key];\n\n        var type = uniform.type;\n\n        if (type === 'sampler2D')\n        {\n            uniform._init = false;\n\n            if (uniform.value !== null)\n            {\n                this.initSampler2D(uniform);\n            }\n        }\n        else if (type === 'mat2' || type === 'mat3' || type === 'mat4')\n        {\n            //  These require special handling\n            uniform.glMatrix = true;\n            uniform.glValueLength = 1;\n\n            if (type === 'mat2')\n            {\n                uniform.glFunc = gl.uniformMatrix2fv;\n            }\n            else if (type === 'mat3')\n            {\n                uniform.glFunc = gl.uniformMatrix3fv;\n            }\n            else if (type === 'mat4')\n            {\n                uniform.glFunc = gl.uniformMatrix4fv;\n            }\n        }\n        else\n        {\n            //  GL function reference\n            uniform.glFunc = gl['uniform' + type];\n\n            if (type === '2f' || type === '2i')\n            {\n                uniform.glValueLength = 2;\n            }\n            else if (type === '3f' || type === '3i')\n            {\n                uniform.glValueLength = 3;\n            }\n            else if (type === '4f' || type === '4i')\n            {\n                uniform.glValueLength = 4;\n            }\n            else\n            {\n                uniform.glValueLength = 1;\n            }\n        }\n    }\n\n};\n\n/**\n* Initialises a Sampler2D uniform (which may only be available later on after initUniforms once the texture has loaded)\n*\n* @method PIXI.PixiShader#initSampler2D\n*/\nPIXI.PixiShader.prototype.initSampler2D = function (uniform)\n{\n    if (!uniform.value || !uniform.value.baseTexture || !uniform.value.baseTexture.hasLoaded)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n\n    // No need to do string manipulation for this.\n    gl.activeTexture(gl.TEXTURE0 + this.textureCount);\n    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);\n\n    //  Extended texture data\n    if (uniform.textureData)\n    {\n        var data = uniform.textureData;\n\n        // GLTexture = mag linear, min linear_mipmap_linear, wrap repeat + gl.generateMipmap(gl.TEXTURE_2D);\n        // GLTextureLinear = mag/min linear, wrap clamp\n        // GLTextureNearestRepeat = mag/min NEAREST, wrap repeat\n        // GLTextureNearest = mag/min nearest, wrap clamp\n        // AudioTexture = whatever + luminance + width 512, height 2, border 0\n        // KeyTexture = whatever + luminance + width 256, height 2, border 0\n\n        //  magFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\n        //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\n\n        var magFilter = (data.magFilter) ? data.magFilter : gl.LINEAR;\n        var minFilter = (data.minFilter) ? data.minFilter : gl.LINEAR;\n        var wrapS = (data.wrapS) ? data.wrapS : gl.CLAMP_TO_EDGE;\n        var wrapT = (data.wrapT) ? data.wrapT : gl.CLAMP_TO_EDGE;\n        var format = (data.luminance) ? gl.LUMINANCE : gl.RGBA;\n\n        if (data.repeat)\n        {\n            wrapS = gl.REPEAT;\n            wrapT = gl.REPEAT;\n        }\n\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\n\n        if (data.width)\n        {\n            var width = (data.width) ? data.width : 512;\n            var height = (data.height) ? data.height : 2;\n            var border = (data.border) ? data.border : 0;\n\n            // void texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels);\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\n        }\n        else\n        {\n            //  void texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels);\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.value.baseTexture.source);\n        }\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n    }\n\n    gl.uniform1i(uniform.uniformLocation, this.textureCount);\n\n    uniform._init = true;\n\n    this.textureCount++;\n\n};\n\n/**\n* Updates the shader uniform values.\n*\n* @method PIXI.PixiShader#syncUniforms\n*/\nPIXI.PixiShader.prototype.syncUniforms = function ()\n{\n    this.textureCount = 1;\n    var uniform;\n    var gl = this.gl;\n\n    //  This would probably be faster in an array and it would guarantee key order\n    for (var key in this.uniforms)\n    {\n        uniform = this.uniforms[key];\n        if (uniform.glValueLength === 1)\n        {\n            if (uniform.glMatrix === true)\n            {\n                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.transpose, uniform.value);\n            }\n            else\n            {\n                uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value);\n            }\n        }\n        else if (uniform.glValueLength === 2)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y);\n        }\n        else if (uniform.glValueLength === 3)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z);\n        }\n        else if (uniform.glValueLength === 4)\n        {\n            uniform.glFunc.call(gl, uniform.uniformLocation, uniform.value.x, uniform.value.y, uniform.value.z, uniform.value.w);\n        }\n        else if (uniform.type === 'sampler2D')\n        {\n            if (uniform._init)\n            {\n                gl.activeTexture(gl['TEXTURE' + this.textureCount]);\n\n                if(uniform.value.baseTexture._dirty[gl.id])\n                {\n                    PIXI.instances[gl.id].updateTexture(uniform.value.baseTexture);\n                }\n                else\n                {\n                    // bind the current texture\n                    gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id]);\n                }\n\n                //  gl.bindTexture(gl.TEXTURE_2D, uniform.value.baseTexture._glTextures[gl.id] || PIXI.createWebGLTexture( uniform.value.baseTexture, gl));\n                gl.uniform1i(uniform.uniformLocation, this.textureCount);\n                this.textureCount++;\n            }\n            else\n            {\n                this.initSampler2D(uniform);\n            }\n        }\n    }\n\n};\n\n/**\n* Destroys the shader.\n*\n* @method PIXI.PixiShader#destroy\n*/\nPIXI.PixiShader.prototype.destroy = function ()\n{\n    this.gl.deleteProgram(this.program);\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n* The Default Vertex shader source.\n*\n* @property defaultVertexSrc\n* @type String\n*/\nPIXI.PixiShader.defaultVertexSrc = [\n    '// PixiShader Vertex Shader',\n    '// With multi-texture rendering',\n    'attribute vec2 aVertexPosition;',\n    'attribute vec2 aTextureCoord;',\n    'attribute vec4 aColor;',\n    'attribute float aTextureIndex;',\n\n    'uniform vec2 projectionVector;',\n    'uniform vec2 offsetVector;',\n\n    'varying vec2 vTextureCoord;',\n    'varying vec4 vColor;',\n    'varying float vTextureIndex;',\n\n    'const vec2 center = vec2(-1.0, 1.0);',\n\n    'void main(void) {',\n    '   if (aTextureIndex > 0.0) gl_Position = vec4(0.0);',\n    '   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);',\n    '   vTextureCoord = aTextureCoord;',\n    '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',\n    '   vTextureIndex = aTextureIndex;',\n    '}'\n];\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * @class PIXI.PixiFastShader\n * @constructor\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.PixiFastShader = function (gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = Phaser._UID++;\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type Any\n     */\n    this.program = null;\n\n    if (PIXI._enableMultiTextureToggle)\n    {\n        var gl = this.gl;\n        this.MAX_TEXTURES = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n        var dynamicIfs = '\\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\\n';\n        for (var index = 1; index < this.MAX_TEXTURES; ++index)\n        {\n            dynamicIfs += '\\tif (vTextureIndex == ' +\n                        index + '.0) { gl_FragColor = texture2D(uSamplerArray[' +\n                        index + '], vTextureCoord) * vColor;return;}\\n';\n        }\n\n        /**\n         * The fragment shader.\n         * @property fragmentSrc\n         * @type Array\n         */\n        this.fragmentSrc = [\n            '// PixiFastShader Fragment Shader.',\n            'precision lowp float;',\n            'bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }',\n            'varying vec2 vTextureCoord;',\n            'varying float vColor;',\n            'varying float vTextureIndex;',\n            'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + '];',\n\n            // Blue color means that you are trying to bound\n            // a texture out of the limits of the hardware.\n            'const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);',\n\n            // If you get a red color means you are out of memory\n            // or in some way corrupted the vertex buffer.\n            'const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);',\n            'void main(void) {',\n            dynamicIfs,\n            '   if(vTextureIndex >= ' + this.MAX_TEXTURES + '.0) { gl_FragColor = BLUE;return;}',\n            '   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}',\n            '}'\n        ];\n    }\n    else\n    {\n        this.fragmentSrc = [\n            '// PixiFastShader Fragment Shader.',\n            'precision lowp float;',\n            'varying vec2 vTextureCoord;',\n            'varying float vColor;',\n            'varying float vTextureIndex;',\n            'uniform sampler2D uSampler;',\n            'void main(void) {',\n            '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;',\n            '}'\n        ];\n    }\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc = [\n        '// PixiFastShader Vertex Shader.',\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aPositionCoord;',\n        'attribute vec2 aScale;',\n        'attribute float aRotation;',\n        'attribute vec2 aTextureCoord;',\n        'attribute float aColor;',\n        'attribute float aTextureIndex;',\n\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        'uniform mat3 uMatrix;',\n\n        'varying vec2 vTextureCoord;',\n        'varying float vColor;',\n        'varying float vTextureIndex;',\n\n        'const vec2 center = vec2(-1.0, 1.0);',\n\n        'void main(void) {',\n        '   vec2 v;',\n        '   vec2 sv = aVertexPosition * aScale;',\n        '   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);',\n        '   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);',\n        '   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;',\n        '   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);',\n        '   vTextureCoord = aTextureCoord;',\n        '   vTextureIndex = aTextureIndex;',\n\n        //  '   vec3 color = mod(vec3(aColor.y/65536.0, aColor.y/256.0, aColor.y), 256.0) / 256.0;',\n        '   vColor = aColor;',\n        '}'\n    ];\n\n    /**\n     * A local texture counter for multi-texture shaders.\n     * @property textureCount\n     * @type Number\n     */\n    this.textureCount = 0;\n\n    this.init();\n};\n\nPIXI.PixiFastShader.prototype.constructor = PIXI.PixiFastShader;\n\n/**\n * Initialises the shader.\n *\n * @method PIXI.PixiFastShader#init\n */\nPIXI.PixiFastShader.prototype.init = function ()\n{\n\n    var gl = this.gl;\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = PIXI._enableMultiTextureToggle ?\n        gl.getUniformLocation(program, 'uSamplerArray[0]') :\n        gl.getUniformLocation(program, 'uSampler');\n\n    if (PIXI._enableMultiTextureToggle)\n    {\n        var indices = [];\n\n        // HACK: we bind an empty texture to avoid WebGL warning spam.\n        var tempTexture = gl.createTexture();\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, tempTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, null);\n        for (var i = 0; i < this.MAX_TEXTURES; ++i)\n        {\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, tempTexture);\n            indices.push(i);\n        }\n        gl.activeTexture(gl.TEXTURE0);\n        gl.uniform1iv(this.uSampler, indices);\n    }\n\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.dimensions = gl.getUniformLocation(program, 'dimensions');\n    this.uMatrix = gl.getUniformLocation(program, 'uMatrix');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aPositionCoord = gl.getAttribLocation(program, 'aPositionCoord');\n\n    this.aScale = gl.getAttribLocation(program, 'aScale');\n    this.aRotation = gl.getAttribLocation(program, 'aRotation');\n\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    this.aTextureIndex = gl.getAttribLocation(program, 'aTextureIndex');\n\n    // Begin worst hack eva //\n\n    // WHY??? ONLY on my chrome pixel the line above returns -1 when using filters?\n    // maybe its somthing to do with the current state of the gl context.\n    // Im convinced this is a bug in the chrome browser as there is NO reason why this should be returning -1 especially as it only manifests on my chrome pixel\n    // If theres any webGL people that know why could happen please help :)\n    if (this.colorAttribute === -1)\n    {\n        this.colorAttribute = 2;\n    }\n\n    this.attributes = [\n        this.aVertexPosition,\n        this.aPositionCoord,\n        this.aScale,\n        this.aRotation,\n        this.aTextureCoord,\n        this.colorAttribute,\n        this.aTextureIndex\n    ];\n\n    // End worst hack eva //\n\n    this.program = program;\n};\n\n/**\n * Destroys the shader.\n *\n * @method PIXI.PixiFastShader#destroy\n */\nPIXI.PixiFastShader.prototype.destroy = function ()\n{\n    this.gl.deleteProgram(this.program);\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PIXI.StripShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.StripShader = function (gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = Phaser._UID++;\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type Any\n     */\n    this.program = null;\n\n    if (PIXI._enableMultiTextureToggle)\n    {\n        var gl = this.gl;\n        this.MAX_TEXTURES = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n        var dynamicIfs = '\\tif (vTextureIndex == 0.0) { gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord);return;}\\n';\n        for (var index = 1; index < this.MAX_TEXTURES; ++index)\n        {\n            dynamicIfs += '\\tif (vTextureIndex == ' +\n                        index + '.0) { gl_FragColor = texture2D(uSamplerArray[' +\n                        index + '], vTextureCoord) ;return;}\\n';\n        }\n\n\n        /**\n         * The fragment shader.\n         * @property fragmentSrc\n         * @type Array\n         */\n        this.fragmentSrc = [\n            '//StripShader Fragment Shader.',\n            'precision mediump float;',\n            'bool isnan( float val ) {  return ( val < 0.0 || 0.0 < val || val == 0.0 ) ? false : true; }',\n            'varying vec2 vTextureCoord;',\n            'varying float vTextureIndex;',\n\n            //   'varying float vColor;',\n            'uniform float alpha;',\n            'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + '];',\n\n            // Blue color means that you are trying to bound\n            // a texture out of the limits of the hardware.\n            'const vec4 BLUE = vec4(1.0, 0.0, 1.0, 1.0);',\n\n            // If you get a red color means you are out of memory\n            // or in some way corrupted the vertex buffer.\n            'const vec4 RED = vec4(1.0, 0.0, 0.0, 1.0);',\n            'void main(void) {',\n            dynamicIfs,\n            '   if(vTextureIndex >= ' + this.MAX_TEXTURES + '.0) { gl_FragColor = BLUE;return;}',\n            '   if(isnan(vTextureIndex)) {gl_FragColor = RED;return;}',\n            '}'\n        ];\n    }\n    else\n    {\n        /**\n         * The fragment shader.\n         * @property fragmentSrc\n         * @type Array\n         */\n        this.fragmentSrc = [\n            '//StripShader Fragment Shader.',\n            'precision mediump float;',\n            'varying vec2 vTextureCoord;',\n            'varying float vTextureIndex;',\n\n            //   'varying float vColor;',\n            'uniform float alpha;',\n            'uniform sampler2D uSampler;',\n            'void main(void) {',\n            '   gl_FragColor = texture2D(uSampler, vTextureCoord);',\n            '}'\n        ];\n    }\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc = [\n        '//StripShader Vertex Shader.',\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aTextureCoord;',\n        'attribute float aTextureIndex;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n\n        //  'uniform float alpha;',\n        // 'uniform vec3 tint;',\n        'varying vec2 vTextureCoord;',\n        'varying float vTextureIndex;',\n\n        //  'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);',\n        '   vTextureCoord = aTextureCoord;',\n        '   vTextureIndex = aTextureIndex;',\n\n        // '   vColor = aColor * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\nPIXI.StripShader.prototype.constructor = PIXI.StripShader;\n\n/**\n* Initialises the shader.\n*\n* @method PIXI.StripShader#init\n*/\nPIXI.StripShader.prototype.init = function ()\n{\n    var gl = this.gl;\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.uSampler = PIXI._enableMultiTextureToggle ?\n        gl.getUniformLocation(program, 'uSamplerArray[0]') :\n        gl.getUniformLocation(program, 'uSampler');\n\n\n    if (PIXI._enableMultiTextureToggle)\n    {\n        var indices = [];\n\n        // HACK: we bind an empty texture to avoid WebGL warning spam.\n        var tempTexture = gl.createTexture();\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, tempTexture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, null);\n        for (var i = 0; i < this.MAX_TEXTURES; ++i)\n        {\n            gl.activeTexture(gl.TEXTURE0 + i);\n            gl.bindTexture(gl.TEXTURE_2D, tempTexture);\n            indices.push(i);\n        }\n        gl.activeTexture(gl.TEXTURE0);\n        gl.uniform1iv(this.uSampler, indices);\n    }\n\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n    this.aTextureIndex = gl.getAttribLocation(program, 'aTextureIndex');\n\n    // this.dimensions = gl.getUniformLocation(this.program, 'dimensions');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.aTextureCoord = gl.getAttribLocation(program, 'aTextureCoord');\n\n    this.attributes = [ this.aVertexPosition, this.aTextureCoord, this.aTextureIndex ];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n*\n* @method PIXI.StripShader#destroy\n*/\nPIXI.StripShader.prototype.destroy = function ()\n{\n    this.gl.deleteProgram(this.program);\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attribute = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PIXI.PrimitiveShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.PrimitiveShader = function (gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = Phaser._UID++;\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type Any\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n        'precision mediump float;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   gl_FragColor = vColor;',\n        '}'\n    ];\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc = [\n        'attribute vec2 aVertexPosition;',\n        'attribute vec4 aColor;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n        'uniform float alpha;',\n        'uniform float flipY;',\n        'uniform vec3 tint;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);',\n        '   vColor = aColor * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\nPIXI.PrimitiveShader.prototype.constructor = PIXI.PrimitiveShader;\n\n/**\n* Initialises the shader.\n*\n* @method PIXI.PrimitiveShader#init\n*/\nPIXI.PrimitiveShader.prototype.init = function ()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.tintColor = gl.getUniformLocation(program, 'tint');\n    this.flipY = gl.getUniformLocation(program, 'flipY');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n    this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    this.attributes = [ this.aVertexPosition, this.colorAttribute ];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n*\n* @method PIXI.PrimitiveShader#destroy\n*/\nPIXI.PrimitiveShader.prototype.destroy = function ()\n{\n    this.gl.deleteProgram(this.program);\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attributes = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PIXI.ComplexPrimitiveShader\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.ComplexPrimitiveShader = function (gl)\n{\n    /**\n     * @property _UID\n     * @type Number\n     * @private\n     */\n    this._UID = Phaser._UID++;\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    /**\n     * The WebGL program.\n     * @property program\n     * @type Any\n     */\n    this.program = null;\n\n    /**\n     * The fragment shader.\n     * @property fragmentSrc\n     * @type Array\n     */\n    this.fragmentSrc = [\n\n        'precision mediump float;',\n\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   gl_FragColor = vColor;',\n        '}'\n    ];\n\n    /**\n     * The vertex shader.\n     * @property vertexSrc\n     * @type Array\n     */\n    this.vertexSrc = [\n        'attribute vec2 aVertexPosition;',\n\n        // 'attribute vec4 aColor;',\n        'uniform mat3 translationMatrix;',\n        'uniform vec2 projectionVector;',\n        'uniform vec2 offsetVector;',\n\n        'uniform vec3 tint;',\n        'uniform float alpha;',\n        'uniform vec3 color;',\n        'uniform float flipY;',\n        'varying vec4 vColor;',\n\n        'void main(void) {',\n        '   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);',\n        '   v -= offsetVector.xyx;',\n        '   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);',\n        '   vColor = vec4(color * alpha * tint, alpha);',// \" * vec4(tint * alpha, alpha);',\n        '}'\n    ];\n\n    this.init();\n};\n\nPIXI.ComplexPrimitiveShader.prototype.constructor = PIXI.ComplexPrimitiveShader;\n\n/**\n* Initialises the shader.\n*\n* @method PIXI.ComplexPrimitiveShader#init\n*/\nPIXI.ComplexPrimitiveShader.prototype.init = function ()\n{\n    var gl = this.gl;\n\n    var program = PIXI.compileProgram(gl, this.vertexSrc, this.fragmentSrc);\n    gl.useProgram(program);\n\n    // get and store the uniforms for the shader\n    this.projectionVector = gl.getUniformLocation(program, 'projectionVector');\n    this.offsetVector = gl.getUniformLocation(program, 'offsetVector');\n    this.tintColor = gl.getUniformLocation(program, 'tint');\n    this.color = gl.getUniformLocation(program, 'color');\n    this.flipY = gl.getUniformLocation(program, 'flipY');\n\n    // get and store the attributes\n    this.aVertexPosition = gl.getAttribLocation(program, 'aVertexPosition');\n\n    // this.colorAttribute = gl.getAttribLocation(program, 'aColor');\n\n    this.attributes = [ this.aVertexPosition, this.colorAttribute ];\n\n    this.translationMatrix = gl.getUniformLocation(program, 'translationMatrix');\n    this.alpha = gl.getUniformLocation(program, 'alpha');\n\n    this.program = program;\n};\n\n/**\n* Destroys the shader.\n*\n* @method PIXI.ComplexPrimitiveShader#destroy\n*/\nPIXI.ComplexPrimitiveShader.prototype.destroy = function ()\n{\n    this.gl.deleteProgram(this.program);\n    this.uniforms = null;\n    this.gl = null;\n\n    this.attribute = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\nPIXI.glContexts = []; // this is where we store the webGL contexts for easy access.\nPIXI.instances = [];\nPIXI._enableMultiTextureToggle = false;\n\n/**\n * The WebGLRenderer draws the stage and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class PIXI.WebGLRenderer\n * @constructor\n * @param game {Phaser.Game} A reference to the Phaser Game instance\n */\nPIXI.WebGLRenderer = function (game, config)\n{\n\n    /**\n    * @property {Phaser.Game} game - A reference to the Phaser Game instance.\n    */\n    this.game = game;\n\n    if (!PIXI.defaultRenderer)\n    {\n        PIXI.defaultRenderer = this;\n    }\n\n    this.extensions = {};\n\n    /**\n     * @property type\n     * @type Number\n     */\n    this.type = Phaser.WEBGL;\n\n    /**\n     * The resolution of the renderer\n     *\n     * @property resolution\n     * @type Number\n     * @default 1\n     */\n    this.resolution = game.resolution;\n\n    /**\n     * Whether the render view is transparent\n     *\n     * @property transparent\n     * @type Boolean\n     */\n    this.transparent = game.transparent;\n\n    /**\n     * Whether the render view should be resized automatically\n     *\n     * @property autoResize\n     * @type Boolean\n     */\n    this.autoResize = false;\n\n    /**\n     * The value of the preserveDrawingBuffer flag affects whether or not the contents of the stencil buffer is retained after rendering.\n     *\n     * @property preserveDrawingBuffer\n     * @type Boolean\n     */\n    this.preserveDrawingBuffer = game.preserveDrawingBuffer;\n\n    /**\n     * This sets if the WebGLRenderer will clear the context texture or not before the new render pass. If true:\n     * If the Stage is NOT transparent, Pixi will clear to alpha (0, 0, 0, 0).\n     * If the Stage is transparent, Pixi will clear to the target Stage's background color.\n     * Disable this by setting this to false. For example: if your game has a canvas filling background image, you often don't need this set.\n     *\n     * @property clearBeforeRender\n     * @type Boolean\n     * @default\n     */\n    this.clearBeforeRender = game.clearBeforeRender;\n\n    /**\n     * The width of the canvas view\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = game.width;\n\n    /**\n     * The height of the canvas view\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = game.height;\n\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @property view\n     * @type HTMLCanvasElement\n     */\n    this.view = game.canvas;\n\n    /**\n     * @property _contextOptions\n     * @type Object\n     * @private\n     */\n    this._contextOptions = {\n        alpha: this.transparent,\n        antialias: game.antialias,\n        failIfMajorPerformanceCaveat: config.failIfMajorPerformanceCaveat,\n        premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',\n        stencil: true,\n        preserveDrawingBuffer: this.preserveDrawingBuffer\n    };\n\n    /**\n     * @property projection\n     * @type Point\n     */\n    this.projection = new PIXI.Point();\n\n    /**\n     * @property offset\n     * @type Point\n     */\n    this.offset = new PIXI.Point();\n\n    // time to create the render managers! each one focuses on managing a state in webGL\n\n    /**\n     * Deals with managing the shader programs and their attribs\n     * @property shaderManager\n     * @type WebGLShaderManager\n     */\n    this.shaderManager = new PIXI.WebGLShaderManager();\n\n    /**\n     * Manages the rendering of sprites\n     * @property spriteBatch\n     * @type WebGLSpriteBatch\n     */\n    this.spriteBatch = new PIXI.WebGLSpriteBatch(game);\n\n    /**\n     * Manages the masks using the stencil buffer\n     * @property maskManager\n     * @type WebGLMaskManager\n     */\n    this.maskManager = new PIXI.WebGLMaskManager();\n\n    /**\n     * Manages the filters\n     * @property filterManager\n     * @type WebGLFilterManager\n     */\n    this.filterManager = new PIXI.WebGLFilterManager();\n\n    /**\n     * Manages the stencil buffer\n     * @property stencilManager\n     * @type WebGLStencilManager\n     */\n    this.stencilManager = new PIXI.WebGLStencilManager();\n\n    /**\n     * Manages the blendModes\n     * @property blendModeManager\n     * @type WebGLBlendModeManager\n     */\n    this.blendModeManager = new PIXI.WebGLBlendModeManager();\n\n    /**\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = {};\n\n    /**\n     * @property currentBatchedTextures\n     * @type Array\n     */\n    this.currentBatchedTextures = [];\n\n    //  Needed?\n    this.renderSession.game = this.game;\n    this.renderSession.gl = this.gl;\n    this.renderSession.drawCount = 0;\n    this.renderSession.shaderManager = this.shaderManager;\n    this.renderSession.maskManager = this.maskManager;\n    this.renderSession.filterManager = this.filterManager;\n    this.renderSession.blendModeManager = this.blendModeManager;\n    this.renderSession.spriteBatch = this.spriteBatch;\n    this.renderSession.stencilManager = this.stencilManager;\n    this.renderSession.renderer = this;\n    this.renderSession.resolution = this.resolution;\n    this.renderSession.roundPixels = config.roundPixels || false;\n    this.renderSession.maxTextureAvailableSpace = null; // filled in setTexturePriority()\n\n    // time init the context..\n    this.initContext();\n\n    // map some webGL blend modes..\n    this.mapBlendModes();\n\n};\n\n// constructor\nPIXI.WebGLRenderer.prototype.constructor = PIXI.WebGLRenderer;\n\n/**\n* @method PIXI.WebGLRenderer#initContext\n*/\nPIXI.WebGLRenderer.prototype.initContext = function ()\n{\n    var gl = this.view.getContext('webgl', this._contextOptions) || this.view.getContext('experimental-webgl', this._contextOptions);\n\n    this.gl = gl;\n\n    if (!gl)\n    {\n        // fail, not able to get a context\n        throw new Error('This browser does not support webGL. Try using the canvas renderer');\n    }\n\n    this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.maxTextureSize = this.gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\n    this.glContextId = gl.id = PIXI.WebGLRenderer.glContextId++;\n\n    PIXI.glContexts[this.glContextId] = gl;\n\n    PIXI.instances[this.glContextId] = this;\n\n    // set up the default pixi settings..\n    gl.disable(gl.DEPTH_TEST);\n    gl.disable(gl.CULL_FACE);\n    gl.enable(gl.BLEND);\n\n    // need to set the context for all the managers...\n    this.shaderManager.setContext(gl);\n    this.spriteBatch.setContext(gl);\n    this.maskManager.setContext(gl);\n    this.filterManager.setContext(gl);\n    this.blendModeManager.setContext(gl);\n    this.stencilManager.setContext(gl);\n\n    this.renderSession.gl = this.gl;\n\n    // now resize and we are good to go!\n    this.resize(this.width, this.height);\n\n    // Load WebGL extension\n    this.extensions.compression = {};\n\n    var etc1 = gl.getExtension('WEBGL_compressed_texture_etc1') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_etc1');\n    var pvrtc = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n    var s3tc = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');\n\n    if (etc1) { this.extensions.compression.ETC1 = etc1; }\n    if (pvrtc) { this.extensions.compression.PVRTC = pvrtc; }\n    if (s3tc) { this.extensions.compression.S3TC = s3tc; }\n};\n\n/**\n* If Multi Texture support has been enabled, then calling this method will enable batching on the given\n* textures. The texture collection is an array of keys, that map to Phaser.Cache image entries.\n*\n* The number of textures that can be batched is dependent on hardware. If you provide more textures\n* than can be batched by the GPU, then only those at the start of the array will be used. Generally\n* you shouldn't provide more than 16 textures to this method. You can check the hardware limit via the\n* `maxTextures` property.\n*\n* You can also check the property `currentBatchedTextures` at any time, to see which textures are currently\n* being batched.\n*\n* To stop all textures from being batched, call this method again with an empty array.\n*\n* To change the textures being batched, call this method with a new array of image keys. The old ones\n* will all be purged out and no-longer batched, and the new ones enabled.\n*\n* Note: Throws a warning if you haven't enabled Multiple Texture batching support in the Phaser Game config.\n*\n* @method PIXI.WebGLRenderer#setTexturePriority\n* @param textureNameCollection {Array} An Array of Texture Cache keys to use for multi-texture batching.\n* @return {Array} An array containing the texture keys that were enabled for batching.\n*/\nPIXI.WebGLRenderer.prototype.setTexturePriority = function (textureNameCollection)\n{\n\n    if (!PIXI._enableMultiTextureToggle)\n    {\n        console.warn('setTexturePriority error: Multi Texture support hasn\\'t been enabled in the Phaser Game Config.');\n        return;\n    }\n    var clampPot = function (potSize)\n    {\n        --potSize;\n        potSize |= potSize >> 1;\n        potSize |= potSize >> 2;\n        potSize |= potSize >> 4;\n        potSize |= potSize >> 8;\n        potSize |= potSize >> 16;\n        return ++potSize;\n    };\n    var gl = this.gl;\n    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    var imageCache = this.game.cache._cache.image;\n    var imageName = null;\n\n    //  Clear out all previously batched textures and reset their flags.\n    //  If the array has been modified, then the developer will have to\n    //  deal with that in their own way.\n    for (var i = 0; i < this.currentBatchedTextures.length; i++)\n    {\n        imageName = this.currentBatchedTextures[i];\n\n        if (!(imageName in imageCache))\n        {\n            console.warn('setTexturePriority: There is no image \"%s\" in the image cache.', imageName);\n            continue;\n        }\n\n        imageCache[imageName].base.textureIndex = 0;\n    }\n    var maxTextureAvailableSpace = (maxTextureSize) - clampPot(Math.max(this.width, this.height));\n    this.currentBatchedTextures.length = 0;\n\n    // We start from 1 because framebuffer texture uses unit 0.\n    for (var j = 0; j < textureNameCollection.length; ++j)\n    {\n        imageName = textureNameCollection[j];\n\n        if (!(imageName in imageCache))\n        {\n            console.warn('setTexturePriority: There is no image \"%s\" in the image cache.', imageName);\n            continue;\n        }\n\n        // Unit 0 is reserved for Pixi's framebuffer\n        var base = imageCache[imageName].base;\n        maxTextureAvailableSpace -= clampPot(Math.max(base.width, base.height));\n        if (maxTextureAvailableSpace <= 0)\n        {\n            base.textureIndex = 0;\n            console.warn('setTexturePriority: Image \"%s\" was given textureIndex=0 because there is no available texture space (%s).',\n                imageName, maxTextureAvailableSpace);\n        }\n        else\n        {\n            base.textureIndex = (1 + (j % (maxTextures - 1)));\n        }\n        this.currentBatchedTextures.push(imageName);\n    }\n\n    this.renderSession.maxTextureAvailableSpace = maxTextureAvailableSpace;\n\n    return this.currentBatchedTextures;\n\n};\n\n/**\n * Renders the stage to its webGL view\n *\n * @method PIXI.WebGLRenderer#render\n * @param stage {Stage} the Stage element to be rendered\n */\nPIXI.WebGLRenderer.prototype.render = function (stage)\n{\n    // no point rendering if our context has been blown up!\n    if (this.contextLost)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n\n    // -- Does this need to be set every frame? -- //\n    gl.viewport(0, 0, this.width, this.height);\n\n    // make sure we are bound to the main frame buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n    if (this.game.clearBeforeRender)\n    {\n        gl.clearColor(stage._bgColor.r, stage._bgColor.g, stage._bgColor.b, stage._bgColor.a);\n\n        gl.clear(gl.COLOR_BUFFER_BIT);\n    }\n\n    this.offset.x = this.game.camera._shake.x;\n    this.offset.y = this.game.camera._shake.y;\n\n    this.renderDisplayObject(stage, this.projection);\n};\n\n/**\n * Renders a Display Object.\n *\n * @method PIXI.WebGLRenderer#renderDisplayObject\n * @param displayObject {DisplayObject} The DisplayObject to render\n * @param projection {Point} The projection\n * @param buffer {Array} a standard WebGL buffer\n */\nPIXI.WebGLRenderer.prototype.renderDisplayObject = function (displayObject, projection, buffer, matrix)\n{\n    this.renderSession.blendModeManager.setBlendMode(PIXI.blendModes.NORMAL);\n\n    // reset the render session data..\n    this.renderSession.drawCount = 0;\n\n    // make sure to flip the Y if using a render texture..\n    this.renderSession.flipY = buffer ? -1 : 1;\n\n    // set the default projection\n    this.renderSession.projection = projection;\n\n    // set the default offset\n    this.renderSession.offset = this.offset;\n\n    // start the sprite batch\n    this.spriteBatch.begin(this.renderSession);\n\n    // start the filter manager\n    this.filterManager.begin(this.renderSession, buffer);\n\n    // render the scene!\n    displayObject._renderWebGL(this.renderSession, matrix);\n\n    // finish the sprite batch\n    this.spriteBatch.end();\n};\n\n/**\n * Resizes the webGL view to the specified width and height.\n *\n * @method PIXI.WebGLRenderer#resize\n * @param width {Number} the new width of the webGL view\n * @param height {Number} the new height of the webGL view\n */\nPIXI.WebGLRenderer.prototype.resize = function (width, height)\n{\n    this.width = width * this.resolution;\n    this.height = height * this.resolution;\n\n    this.view.width = this.width;\n    this.view.height = this.height;\n\n    if (this.autoResize)\n    {\n        this.view.style.width = this.width / this.resolution + 'px';\n        this.view.style.height = this.height / this.resolution + 'px';\n    }\n\n    this.gl.viewport(0, 0, this.width, this.height);\n\n    this.projection.x = this.width / 2 / this.resolution;\n    this.projection.y = -this.height / 2 / this.resolution;\n};\n\n/**\n * Updates and creates a WebGL compressed texture for the renderers context.\n *\n * @method PIXI.WebGLRenderer#updateCompressedTexture\n * @param texture {Texture} the texture to update\n * @return {boolean} True if the texture was successfully bound, otherwise false.\n */\nPIXI.WebGLRenderer.prototype.updateCompressedTexture = function (texture)\n{\n    if (!texture.hasLoaded)\n    {\n        return false;\n    }\n    var gl = this.gl;\n    var textureMetaData = texture.source;\n\n    if (!texture._glTextures[gl.id])\n    {\n        texture._glTextures[gl.id] = gl.createTexture();\n    }\n    gl.activeTexture(gl.TEXTURE0 + texture.textureIndex);\n\n    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n\n    gl.compressedTexImage2D(\n        gl.TEXTURE_2D,\n        0,\n        textureMetaData.glExtensionFormat,\n        textureMetaData.width,\n        textureMetaData.height,\n        0,\n        textureMetaData.textureData\n    );\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n\n    if (texture.mipmap && Phaser.Math.isPowerOfTwo(texture.width, texture.height))\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n        gl.generateMipmap(gl.TEXTURE_2D);\n    }\n    else\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n\n    if (!texture._powerOf2)\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n    else\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n    }\n    texture._dirty[gl.id] = false;\n    return true;\n};\n\n/**\n * Updates and Creates a WebGL texture for the renderers context.\n *\n * @method PIXI.WebGLRenderer#updateTexture\n * @param texture {Texture} the texture to update\n * @return {boolean} True if the texture was successfully bound, otherwise false.\n */\nPIXI.WebGLRenderer.prototype.updateTexture = function (texture)\n{\n    if (!texture.hasLoaded)\n    {\n        return false;\n    }\n    if (texture.source.compressionAlgorithm)\n    {\n        return this.updateCompressedTexture(texture);\n    }\n\n    var gl = this.gl;\n\n    if (!texture._glTextures[gl.id])\n    {\n        texture._glTextures[gl.id] = gl.createTexture();\n    }\n    gl.activeTexture(gl.TEXTURE0 + texture.textureIndex);\n\n    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultipliedAlpha);\n\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.source);\n\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n\n    if (texture.mipmap && Phaser.Math.isPowerOfTwo(texture.width, texture.height))\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);\n        gl.generateMipmap(gl.TEXTURE_2D);\n    }\n    else\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, texture.scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    }\n\n    if (!texture._powerOf2)\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    }\n    else\n    {\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n    }\n\n    texture._dirty[gl.id] = false;\n\n    // return texture._glTextures[gl.id];\n    return true;\n\n};\n\n/**\n * Removes everything from the renderer (event listeners, spritebatch, etc...)\n *\n * @method PIXI.WebGLRenderer#destroy\n */\nPIXI.WebGLRenderer.prototype.destroy = function ()\n{\n    PIXI.glContexts[this.glContextId] = null;\n\n    this.projection = null;\n    this.offset = null;\n\n    this.shaderManager.destroy();\n    this.spriteBatch.destroy();\n    this.maskManager.destroy();\n    this.filterManager.destroy();\n\n    this.shaderManager = null;\n    this.spriteBatch = null;\n    this.maskManager = null;\n    this.filterManager = null;\n\n    this.gl = null;\n    this.renderSession = null;\n\n    Phaser.CanvasPool.remove(this);\n\n    PIXI.instances[this.glContextId] = null;\n\n    PIXI.WebGLRenderer.glContextId--;\n};\n\n/**\n * Maps Pixi blend modes to WebGL blend modes.\n *\n * @method PIXI.WebGLRenderer#mapBlendModes\n */\nPIXI.WebGLRenderer.prototype.mapBlendModes = function ()\n{\n    var gl = this.gl;\n\n    if (!PIXI.blendModesWebGL)\n    {\n        var b = [];\n        var modes = PIXI.blendModes;\n\n        b[modes.NORMAL] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.ADD] = [ gl.SRC_ALPHA, gl.DST_ALPHA ];\n        b[modes.MULTIPLY] = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.SCREEN] = [ gl.SRC_ALPHA, gl.ONE ];\n        b[modes.OVERLAY] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.DARKEN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.LIGHTEN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.COLOR_DODGE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.COLOR_BURN] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.HARD_LIGHT] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.SOFT_LIGHT] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.DIFFERENCE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.EXCLUSION] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.HUE] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.SATURATION] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.COLOR] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n        b[modes.LUMINOSITY] = [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ];\n\n        PIXI.blendModesWebGL = b;\n    }\n};\n\nPIXI.WebGLRenderer.prototype.getMaxTextureUnit = function ()\n{\n    var gl = this.gl;\n    return gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n};\n\nPIXI.enableMultiTexture = function ()\n{\n    PIXI._enableMultiTextureToggle = true;\n};\n\nPIXI.WebGLRenderer.glContextId = 0;\nPIXI.WebGLRenderer.textureArray = [];\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PIXI.WebGLBlendModeManager\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLBlendModeManager = function ()\n{\n    /**\n     * @property currentBlendMode\n     * @type Number\n     */\n    this.currentBlendMode = 99999;\n};\n\nPIXI.WebGLBlendModeManager.prototype.constructor = PIXI.WebGLBlendModeManager;\n\n/**\n * Sets the WebGL Context.\n *\n * @method PIXI.WebGLBlendModeManager#setContext\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLBlendModeManager.prototype.setContext = function (gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Sets-up the given blendMode from WebGL's point of view.\n*\n* @method PIXI.WebGLBlendModeManager#setBlendMode\n* @param blendMode {Number} the blendMode, should be a Pixi const, such as PIXI.BlendModes.ADD\n*/\nPIXI.WebGLBlendModeManager.prototype.setBlendMode = function (blendMode)\n{\n    if(this.currentBlendMode === blendMode) { return false; }\n\n    this.currentBlendMode = blendMode;\n\n    var blendModeWebGL = PIXI.blendModesWebGL[this.currentBlendMode];\n\n    if (blendModeWebGL)\n    {\n        this.gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);\n    }\n\n    return true;\n};\n\n/**\n* Destroys this object.\n*\n* @method PIXI.WebGLBlendModeManager#destroy\n*/\nPIXI.WebGLBlendModeManager.prototype.destroy = function ()\n{\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PIXI.WebGLMaskManager\n* @constructor\n* @private\n*/\nPIXI.WebGLMaskManager = function ()\n{\n};\n\nPIXI.WebGLMaskManager.prototype.constructor = PIXI.WebGLMaskManager;\n\n/**\n* Sets the drawing context to the one given in parameter.\n*\n* @method PIXI.WebGLMaskManager#setContext\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLMaskManager.prototype.setContext = function (gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Applies the Mask and adds it to the current filter stack.\n*\n* @method PIXI.WebGLMaskManager#pushMask\n* @param maskData {Array}\n* @param renderSession {Object}\n*/\nPIXI.WebGLMaskManager.prototype.pushMask = function (maskData, renderSession)\n{\n    var gl = renderSession.gl;\n\n    if (maskData.dirty)\n    {\n        PIXI.WebGLGraphics.updateGraphics(maskData, gl);\n    }\n\n    if (maskData._webGL[gl.id] === undefined || maskData._webGL[gl.id].data === undefined || maskData._webGL[gl.id].data.length === 0)\n    {\n        return;\n    }\n\n    renderSession.stencilManager.pushStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);\n};\n\n/**\n* Removes the last filter from the filter stack and doesn't return it.\n*\n* @method PIXI.WebGLMaskManager#popMask\n* @param maskData {Array}\n* @param renderSession {Object} an object containing all the useful parameters\n*/\nPIXI.WebGLMaskManager.prototype.popMask = function (maskData, renderSession)\n{\n    var gl = this.gl;\n\n    if (maskData._webGL[gl.id] === undefined || maskData._webGL[gl.id].data === undefined || maskData._webGL[gl.id].data.length === 0)\n    {\n        return;\n    }\n\n    renderSession.stencilManager.popStencil(maskData, maskData._webGL[gl.id].data[0], renderSession);\n\n};\n\n/**\n* Destroys the mask stack.\n*\n* @method PIXI.WebGLMaskManager#destroy\n*/\nPIXI.WebGLMaskManager.prototype.destroy = function ()\n{\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PIXI.WebGLStencilManager\n* @constructor\n* @private\n*/\nPIXI.WebGLStencilManager = function ()\n{\n    this.stencilStack = [];\n    this.reverse = true;\n    this.count = 0;\n};\n\n/**\n* Sets the drawing context to the one given in parameter.\n*\n* @method PIXI.WebGLStencilManager#setContext\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLStencilManager.prototype.setContext = function (gl)\n{\n    this.gl = gl;\n};\n\n/**\n* Applies the Mask and adds it to the current filter stack.\n*\n* @method PIXI.WebGLStencilManager#pushMask\n* @param graphics {Graphics}\n* @param webGLData {Array}\n* @param renderSession {Object}\n*/\nPIXI.WebGLStencilManager.prototype.pushStencil = function (graphics, webGLData, renderSession)\n{\n    var gl = this.gl;\n    this.bindGraphics(graphics, webGLData, renderSession);\n\n    if(this.stencilStack.length === 0)\n    {\n        gl.enable(gl.STENCIL_TEST);\n        gl.clear(gl.STENCIL_BUFFER_BIT);\n        this.reverse = true;\n        this.count = 0;\n    }\n\n    this.stencilStack.push(webGLData);\n\n    var level = this.count;\n\n    gl.colorMask(false, false, false, false);\n\n    gl.stencilFunc(gl.ALWAYS,0,0xFF);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);\n\n    // draw the triangle strip!\n\n    if(webGLData.mode === 1)\n    {\n        gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0);\n\n        if(this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n        }\n\n        // draw a quad to increment..\n        gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);\n\n        if(this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL,0xFF - (level + 1), 0xFF);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level + 1, 0xFF);\n        }\n\n        this.reverse = !this.reverse;\n    }\n    else\n    {\n        if(!this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL, 0xFF - level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n        }\n\n        gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);\n\n        if(!this.reverse)\n        {\n            gl.stencilFunc(gl.EQUAL,0xFF - (level + 1), 0xFF);\n        }\n        else\n        {\n            gl.stencilFunc(gl.EQUAL,level + 1, 0xFF);\n        }\n    }\n\n    gl.colorMask(true, true, true, true);\n    gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n\n    this.count++;\n};\n\n/**\n * TODO this does not belong here!\n *\n * @method PIXI.WebGLStencilManager#bindGraphics\n * @param graphics {Graphics}\n * @param webGLData {Array}\n * @param renderSession {Object}\n */\nPIXI.WebGLStencilManager.prototype.bindGraphics = function (graphics, webGLData, renderSession)\n{\n    // if(this._currentGraphics === graphics)return;\n    this._currentGraphics = graphics;\n\n    var gl = this.gl;\n\n    // bind the graphics object..\n    var projection = renderSession.projection,\n        offset = renderSession.offset,\n        shader;// = renderSession.shaderManager.primitiveShader;\n\n    if(webGLData.mode === 1)\n    {\n        shader = renderSession.shaderManager.complexPrimitiveShader;\n\n        renderSession.shaderManager.setShader(shader);\n\n        gl.uniform1f(shader.flipY, renderSession.flipY);\n\n        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));\n\n        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n\n        gl.uniform3fv(shader.tintColor, Phaser.Color.hexToRGBArray(graphics.tint));\n        gl.uniform3fv(shader.color, webGLData.color);\n\n        gl.uniform1f(shader.alpha, graphics.worldAlpha * webGLData.alpha);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 2, 0);\n\n\n        // now do the rest..\n        // set the index buffer!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n    }\n    else\n    {\n        // renderSession.shaderManager.activatePrimitiveShader();\n        shader = renderSession.shaderManager.primitiveShader;\n        renderSession.shaderManager.setShader(shader);\n\n        gl.uniformMatrix3fv(shader.translationMatrix, false, graphics.worldTransform.toArray(true));\n\n        gl.uniform1f(shader.flipY, renderSession.flipY);\n        gl.uniform2f(shader.projectionVector, projection.x, -projection.y);\n        gl.uniform2f(shader.offsetVector, -offset.x, -offset.y);\n\n        gl.uniform3fv(shader.tintColor, Phaser.Color.hexToRGBArray(graphics.tint));\n\n        gl.uniform1f(shader.alpha, graphics.worldAlpha);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, webGLData.buffer);\n\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 4 * 6, 0);\n        gl.vertexAttribPointer(shader.colorAttribute, 4, gl.FLOAT, false,4 * 6, 2 * 4);\n\n        // set the index buffer!\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, webGLData.indexBuffer);\n    }\n};\n\n/**\n * @method PIXI.WebGLStencilManager#popStencil\n * @param graphics {Graphics}\n * @param webGLData {Array}\n * @param renderSession {Object}\n */\nPIXI.WebGLStencilManager.prototype.popStencil = function (graphics, webGLData, renderSession)\n{\n    var gl = this.gl;\n    this.stencilStack.pop();\n\n    this.count--;\n\n    if(this.stencilStack.length === 0)\n    {\n        // the stack is empty!\n        gl.disable(gl.STENCIL_TEST);\n\n    }\n    else\n    {\n\n        var level = this.count;\n\n        this.bindGraphics(graphics, webGLData, renderSession);\n\n        gl.colorMask(false, false, false, false);\n\n        if(webGLData.mode === 1)\n        {\n            this.reverse = !this.reverse;\n\n            if(this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL, 0xFF - (level + 1), 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level + 1, 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n            }\n\n            // draw a quad to increment..\n            gl.drawElements(gl.TRIANGLE_FAN, 4, gl.UNSIGNED_SHORT, (webGLData.indices.length - 4) * 2);\n\n            gl.stencilFunc(gl.ALWAYS,0,0xFF);\n            gl.stencilOp(gl.KEEP,gl.KEEP,gl.INVERT);\n\n            // draw the triangle strip!\n            gl.drawElements(gl.TRIANGLE_FAN, webGLData.indices.length - 4, gl.UNSIGNED_SHORT, 0);\n\n            if(!this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL,0xFF - (level), 0xFF);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            }\n\n        }\n        else\n        {\n            //  console.log(\"<<>>\")\n            if(!this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL, 0xFF - (level + 1), 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.INCR);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level + 1, 0xFF);\n                gl.stencilOp(gl.KEEP,gl.KEEP,gl.DECR);\n            }\n\n            gl.drawElements(gl.TRIANGLE_STRIP, webGLData.indices.length, gl.UNSIGNED_SHORT, 0);\n\n            if(!this.reverse)\n            {\n                gl.stencilFunc(gl.EQUAL,0xFF - (level), 0xFF);\n            }\n            else\n            {\n                gl.stencilFunc(gl.EQUAL,level, 0xFF);\n            }\n        }\n\n        gl.colorMask(true, true, true, true);\n        gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);\n\n\n    }\n};\n\n/**\n* Destroys the mask stack.\n*\n* @method PIXI.WebGLStencilManager#destroy\n*/\nPIXI.WebGLStencilManager.prototype.destroy = function ()\n{\n    this.stencilStack = null;\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PIXI.WebGLShaderManager\n* @constructor\n* @private\n*/\nPIXI.WebGLShaderManager = function ()\n{\n    /**\n     * @property maxAttibs\n     * @type Number\n     */\n    this.maxAttibs = 10;\n\n    /**\n     * @property attribState\n     * @type Array\n     */\n    this.attribState = [];\n\n    /**\n     * @property tempAttribState\n     * @type Array\n     */\n    this.tempAttribState = [];\n\n    for (var i = 0; i < this.maxAttibs; i++)\n    {\n        this.attribState[i] = false;\n    }\n\n    /**\n     * @property stack\n     * @type Array\n     */\n    this.stack = [];\n\n};\n\nPIXI.WebGLShaderManager.prototype.constructor = PIXI.WebGLShaderManager;\n\n/**\n* Initialises the context and the properties.\n*\n* @method PIXI.WebGLShaderManager#setContext\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLShaderManager.prototype.setContext = function (gl)\n{\n    this.gl = gl;\n\n    // the next one is used for rendering primitives\n    this.primitiveShader = new PIXI.PrimitiveShader(gl);\n\n    // the next one is used for rendering triangle strips\n    this.complexPrimitiveShader = new PIXI.ComplexPrimitiveShader(gl);\n\n    // this shader is used for the default sprite rendering\n    this.defaultShader = new PIXI.PixiShader(gl);\n\n    // this shader is used for the fast sprite rendering\n    this.fastShader = new PIXI.PixiFastShader(gl);\n\n    // the next one is used for rendering triangle strips\n    this.stripShader = new PIXI.StripShader(gl);\n\n    // the next one is used for rendering creature meshes\n    this.creatureShader = PIXI.CreatureShader ? new PIXI.CreatureShader(gl) : null;\n\n    this.setShader(this.defaultShader);\n};\n\n/**\n* Takes the attributes given in parameters.\n*\n* @method PIXI.WebGLShaderManager#setAttribs\n* @param attribs {Array} attribs\n*/\nPIXI.WebGLShaderManager.prototype.setAttribs = function (attribs)\n{\n    // reset temp state\n    var i;\n\n    for (i = 0; i < this.tempAttribState.length; i++)\n    {\n        this.tempAttribState[i] = false;\n    }\n\n    // set the new attribs\n    for (i = 0; i < attribs.length; i++)\n    {\n        var attribId = attribs[i];\n        this.tempAttribState[attribId] = true;\n    }\n\n    var gl = this.gl;\n\n    for (i = 0; i < this.attribState.length; i++)\n    {\n        if(this.attribState[i] !== this.tempAttribState[i])\n        {\n            this.attribState[i] = this.tempAttribState[i];\n\n            if(this.tempAttribState[i])\n            {\n                gl.enableVertexAttribArray(i);\n            }\n            else\n            {\n                gl.disableVertexAttribArray(i);\n            }\n        }\n    }\n};\n\n/**\n* Sets the current shader.\n*\n* @method PIXI.WebGLShaderManager#setShader\n* @param shader {Any}\n*/\nPIXI.WebGLShaderManager.prototype.setShader = function (shader)\n{\n    if(this._currentId === shader._UID) { return false; }\n\n    this._currentId = shader._UID;\n\n    this.currentShader = shader;\n\n    this.gl.useProgram(shader.program);\n    this.setAttribs(shader.attributes);\n\n    return true;\n};\n\n/**\n* Destroys this object.\n*\n* @method PIXI.WebGLShaderManager#destroy\n*/\nPIXI.WebGLShaderManager.prototype.destroy = function ()\n{\n    this.attribState = null;\n\n    this.tempAttribState = null;\n\n    this.primitiveShader.destroy();\n\n    this.complexPrimitiveShader.destroy();\n\n    this.defaultShader.destroy();\n\n    this.fastShader.destroy();\n\n    this.stripShader.destroy();\n\n    if (this.creatureShader)\n    {\n        this.creatureShader.destroy();\n    }\n\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's WebGLSpriteBatch:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java\n */\n\n/**\n *\n * @class PIXI.WebGLSpriteBatch\n * @private\n * @constructor\n */\nPIXI.WebGLSpriteBatch = function (game)\n{\n\n    /**\n    * @property {Phaser.Game} game - A reference to the currently running game.\n    */\n    this.game = game;\n\n    /**\n     * @property vertSize\n     * @type Number\n     */\n    this.vertSize = 5;\n\n    /**\n     * The number of images in the SpriteBatch before it flushes\n     * @property size\n     * @type Number\n     */\n    this.size = 2000; // Math.pow(2, 16) /  this.vertSize;\n\n    // the total number of bytes in our batch\n    // Including texture index:\n    // position + uv + color + textureIndex\n    // vec2 + vec2 + (char * 4) + float\n    this.vertexSize = (4 * 2) + (4 * 2) + (4) + (4);\n    var numVerts = this.vertexSize * this.size * 4;\n\n    // this.size * 4 * 4 * this.vertSize;\n    // the total number of indices in our batch\n    var numIndices = this.size * 6;\n\n    /**\n     * Holds the vertices\n     *\n     * @property vertices\n     * @type ArrayBuffer\n     */\n    this.vertices = new ArrayBuffer(numVerts);\n\n    /**\n     * View on the vertices as a Float32Array\n     *\n     * @property positions\n     * @type Float32Array\n     */\n    this.positions = new Float32Array(this.vertices);\n\n    /**\n     * View on the vertices as a Uint32Array\n     *\n     * @property colors\n     * @type Uint32Array\n     */\n    this.colors = new Uint32Array(this.vertices);\n\n    /**\n     * Holds the indices\n     *\n     * @property indices\n     * @type Uint16Array\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    /**\n     * @property lastIndexCount\n     * @type Number\n     */\n    this.lastIndexCount = 0;\n\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * @property drawing\n     * @type Boolean\n     */\n    this.drawing = false;\n\n    /**\n     * @property currentBatchSize\n     * @type Number\n     */\n    this.currentBatchSize = 0;\n\n    /**\n     * @property currentBaseTexture\n     * @type BaseTexture\n     */\n    this.currentBaseTexture = null;\n\n    /**\n     * @property dirty\n     * @type Boolean\n     */\n    this.dirty = true;\n\n    /**\n     * @property textures\n     * @type Array\n     */\n    this.textures = [];\n\n    /**\n     * @property blendModes\n     * @type Array\n     */\n    this.blendModes = [];\n\n    /**\n     * @property shaders\n     * @type Array\n     */\n    this.shaders = [];\n\n    /**\n     * @property sprites\n     * @type Array\n     */\n    this.sprites = [];\n\n    /**\n     * @property defaultShader\n     * @type Phaser.Filter\n     */\n    this.defaultShader = null;\n};\n\n/**\n * @method PIXI.WebGLSpriteBatch#setContext\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLSpriteBatch.prototype.setContext = function (gl)\n{\n    this.MAX_TEXTURES = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this.gl = gl;\n    if (PIXI._enableMultiTextureToggle)\n    {\n        var dynamicIfs = '\\tif (vTextureIndex == 0.0) {gl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;return;}\\n';\n        for (var index = 1; index < this.MAX_TEXTURES; ++index)\n        {\n            dynamicIfs += '\\tif (vTextureIndex == ' +\n                index + '.0) {gl_FragColor = texture2D(uSamplerArray[' +\n                index + '], vTextureCoord) * vColor;return;}\\n';\n        }\n        this.defaultShader = new Phaser.Filter(\n            this.game,\n            undefined,\n            [\n                '//WebGLSpriteBatch Fragment Shader.',\n                'precision lowp float;',\n                'varying vec2 vTextureCoord;',\n                'varying vec4 vColor;',\n                'varying float vTextureIndex;',\n                'uniform sampler2D uSamplerArray[' + this.MAX_TEXTURES + '];',\n                'void main(void) {',\n                dynamicIfs,\n                '\\tgl_FragColor = texture2D(uSamplerArray[0], vTextureCoord) * vColor;',\n                '}'\n            ]);\n    }\n    else\n    {\n        this.defaultShader = new Phaser.Filter(\n            this.game,\n            undefined,\n            [\n                '//WebGLSpriteBatch Fragment Shader.',\n                'precision lowp float;',\n                'varying vec2 vTextureCoord;',\n                'varying vec4 vColor;',\n                'varying float vTextureIndex;',\n                'uniform sampler2D uSampler;',\n                'void main(void) {',\n                '   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor;',\n                '}'\n            ]);\n    }\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n    // upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n\n    this.currentBlendMode = 99999;\n\n    var shader = new PIXI.PixiShader(gl);\n\n    shader.fragmentSrc = this.defaultShader.fragmentSrc;\n    shader.uniforms = {};\n    shader.init();\n\n    this.defaultShader.shaders[gl.id] = shader;\n};\n\n/**\n * @method PIXI.WebGLSpriteBatch#begin\n * @param renderSession {Object} The RenderSession object\n */\nPIXI.WebGLSpriteBatch.prototype.begin = function (renderSession)\n{\n    this.renderSession = renderSession;\n    this.shader = this.renderSession.shaderManager.defaultShader;\n\n    this.start();\n};\n\n/**\n * @method PIXI.WebGLSpriteBatch#end\n */\nPIXI.WebGLSpriteBatch.prototype.end = function ()\n{\n    this.flush();\n};\n\n/**\n * @method PIXI.WebGLSpriteBatch#render\n * @param sprite {Sprite} the sprite to render when using this spritebatch\n * @param {Matrix} [matrix] - Optional matrix. If provided the Display Object will be rendered using this matrix, otherwise it will use its worldTransform.\n */\nPIXI.WebGLSpriteBatch.prototype.render = function (sprite, matrix)\n{\n    var texture = sprite.texture;\n    var baseTexture = texture.baseTexture;\n    var gl = this.gl;\n    if (PIXI.WebGLRenderer.textureArray[baseTexture.textureIndex] != baseTexture) // eslint-disable-line eqeqeq\n    {\n        this.flush();\n        gl.activeTexture(gl.TEXTURE0 + baseTexture.textureIndex);\n        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);\n        PIXI.WebGLRenderer.textureArray[baseTexture.textureIndex] = baseTexture;\n    }\n\n    //  They provided an alternative rendering matrix, so use it\n    var wt = sprite.worldTransform;\n\n    if (matrix)\n    {\n        wt = matrix;\n    }\n\n    // check texture..\n    if (this.currentBatchSize >= this.size)\n    {\n        this.flush();\n        this.currentBaseTexture = texture.baseTexture;\n    }\n\n    // get the uvs for the texture\n    var uvs = texture._uvs;\n\n    // if the uvs have not updated then no point rendering just yet!\n    if (!uvs)\n    {\n        return;\n    }\n\n    var aX = sprite.anchor.x;\n    var aY = sprite.anchor.y;\n\n    var w0, w1, h0, h1;\n\n    if (texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords.\n        var trim = texture.trim;\n\n        w1 = trim.x - aX * trim.width;\n        w0 = w1 + texture.crop.width;\n\n        h1 = trim.y - aY * trim.height;\n        h0 = h1 + texture.crop.height;\n    }\n    else\n    {\n        w0 = (texture.frame.width) * (1 - aX);\n        w1 = (texture.frame.width) * -aX;\n\n        h0 = texture.frame.height * (1 - aY);\n        h1 = texture.frame.height * -aY;\n    }\n\n    var i = this.currentBatchSize * this.vertexSize; // 4 * this.vertSize;\n    var resolution = texture.baseTexture.resolution;\n    var textureIndex = texture.baseTexture.textureIndex;\n\n    var a = wt.a / resolution;\n    var b = wt.b / resolution;\n    var c = wt.c / resolution;\n    var d = wt.d / resolution;\n    var tx = wt.tx;\n    var ty = wt.ty;\n\n    var ch = texture.crop.height;\n\n    if (texture.rotated)\n    {\n        var a0 = wt.a;\n        var b0 = wt.b;\n        var c0 = wt.c;\n        var d0 = wt.d;\n        var _w1 = w1;\n        var _w0 = w0;\n\n        // Offset before rotating\n        tx = wt.c * ch + tx;\n        ty = wt.d * ch + ty;\n\n        // Rotate matrix by 90 degrees\n        // We use precalculated values for sine and cosine of rad(90)\n        a = a0 * 6.123233995736766e-17 + -c0;\n        b = b0 * 6.123233995736766e-17 + -d0;\n        c = a0 + c0 * 6.123233995736766e-17;\n        d = b0 + d0 * 6.123233995736766e-17;\n\n        // Update UV coordinates\n        texture._updateUvsInverted();\n\n        // Rotate dimensions\n        w0 = h0;\n        w1 = h1;\n        h0 = _w0;\n        h1 = _w1;\n    }\n\n    var colors = this.colors;\n    var positions = this.positions;\n    var tint = sprite.tint;\n    var color = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);\n\n    if (this.renderSession.roundPixels)\n    {\n        positions[i++] = a * w1 + c * h1 + tx | 0;\n        positions[i++] = d * h1 + b * w1 + ty | 0;\n        positions[i++] = uvs.x0;\n        positions[i++] = uvs.y0;\n        colors[i++] = color;\n        positions[i++] = textureIndex;\n\n        positions[i++] = a * w0 + c * h1 + tx | 0;\n        positions[i++] = d * h1 + b * w0 + ty | 0;\n        positions[i++] = uvs.x1;\n        positions[i++] = uvs.y1;\n        colors[i++] = color;\n        positions[i++] = textureIndex;\n\n        positions[i++] = a * w0 + c * h0 + tx | 0;\n        positions[i++] = d * h0 + b * w0 + ty | 0;\n        positions[i++] = uvs.x2;\n        positions[i++] = uvs.y2;\n        colors[i++] = color;\n        positions[i++] = textureIndex;\n\n        positions[i++] = a * w1 + c * h0 + tx | 0;\n        positions[i++] = d * h0 + b * w1 + ty | 0;\n        positions[i++] = uvs.x3;\n        positions[i++] = uvs.y3;\n        colors[i++] = color;\n        positions[i++] = textureIndex;\n    }\n    else\n    {\n        positions[i++] = a * w1 + c * h1 + tx;\n        positions[i++] = d * h1 + b * w1 + ty;\n        positions[i++] = uvs.x0;\n        positions[i++] = uvs.y0;\n        colors[i++] = color;\n        positions[i++] = textureIndex;\n\n        positions[i++] = a * w0 + c * h1 + tx;\n        positions[i++] = d * h1 + b * w0 + ty;\n        positions[i++] = uvs.x1;\n        positions[i++] = uvs.y1;\n        colors[i++] = color;\n        positions[i++] = textureIndex;\n\n        positions[i++] = a * w0 + c * h0 + tx;\n        positions[i++] = d * h0 + b * w0 + ty;\n        positions[i++] = uvs.x2;\n        positions[i++] = uvs.y2;\n        colors[i++] = color;\n        positions[i++] = textureIndex;\n\n        positions[i++] = a * w1 + c * h0 + tx;\n        positions[i++] = d * h0 + b * w1 + ty;\n        positions[i++] = uvs.x3;\n        positions[i++] = uvs.y3;\n        colors[i++] = color;\n        positions[i++] = textureIndex;\n    }\n\n    // increment the batchsize\n    this.sprites[this.currentBatchSize++] = sprite;\n};\n\n/**\n * Renders a TilingSprite using the spriteBatch.\n *\n * @method PIXI.WebGLSpriteBatch#renderTilingSprite\n * @param sprite {TilingSprite} the sprite to render\n */\nPIXI.WebGLSpriteBatch.prototype.renderTilingSprite = function (sprite)\n{\n    var texture = sprite.tilingTexture;\n    var baseTexture = texture.baseTexture;\n    var gl = this.gl;\n    var textureIndex = sprite.texture.baseTexture.textureIndex;\n    if (PIXI.WebGLRenderer.textureArray[textureIndex] != baseTexture) // eslint-disable-line eqeqeq\n    {\n        this.flush();\n        gl.activeTexture(gl.TEXTURE0 + textureIndex);\n        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);\n        PIXI.WebGLRenderer.textureArray[textureIndex] = baseTexture;\n    }\n\n    // check texture..\n    if (this.currentBatchSize >= this.size)\n    {\n        this.flush();\n        this.currentBaseTexture = texture.baseTexture;\n    }\n\n    // set the textures uvs temporarily\n    if (!sprite._uvs)\n    {\n        sprite._uvs = new PIXI.TextureUvs();\n    }\n\n    var uvs = sprite._uvs;\n\n    var w = texture.baseTexture.width;\n    var h = texture.baseTexture.height;\n\n    // var w = sprite._frame.sourceSizeW;\n    // var h = sprite._frame.sourceSizeH;\n\n    // w = 16;\n    // h = 16;\n\n    sprite.tilePosition.x %= w * sprite.tileScaleOffset.x;\n    sprite.tilePosition.y %= h * sprite.tileScaleOffset.y;\n\n    var offsetX = sprite.tilePosition.x / (w * sprite.tileScaleOffset.x);\n    var offsetY = sprite.tilePosition.y / (h * sprite.tileScaleOffset.y);\n\n    var scaleX = (sprite.width / w) / (sprite.tileScale.x * sprite.tileScaleOffset.x);\n    var scaleY = (sprite.height / h) / (sprite.tileScale.y * sprite.tileScaleOffset.y);\n\n    uvs.x0 = 0 - offsetX;\n    uvs.y0 = 0 - offsetY;\n\n    uvs.x1 = (1 * scaleX) - offsetX;\n    uvs.y1 = 0 - offsetY;\n\n    uvs.x2 = (1 * scaleX) - offsetX;\n    uvs.y2 = (1 * scaleY) - offsetY;\n\n    uvs.x3 = 0 - offsetX;\n    uvs.y3 = (1 * scaleY) - offsetY;\n\n    //  Get the sprites current alpha and tint and combine them into a single color\n    var tint = sprite.tint;\n    var color = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);\n\n    var positions = this.positions;\n    var colors = this.colors;\n\n    var width = sprite.width;\n    var height = sprite.height;\n\n    // TODO trim??\n    var aX = sprite.anchor.x;\n    var aY = sprite.anchor.y;\n    var w0 = width * (1 - aX);\n    var w1 = width * -aX;\n\n    var h0 = height * (1 - aY);\n    var h1 = height * -aY;\n\n    var i = this.currentBatchSize * this.vertexSize; // 4 * this.vertSize;\n\n    var resolution = texture.baseTexture.resolution;\n\n    var wt = sprite.worldTransform;\n\n    var a = wt.a / resolution;\n    var b = wt.b / resolution;\n    var c = wt.c / resolution;\n    var d = wt.d / resolution;\n    var tx = wt.tx;\n    var ty = wt.ty;\n\n    // xy\n    positions[i++] = a * w1 + c * h1 + tx;\n    positions[i++] = d * h1 + b * w1 + ty;\n\n    // uv\n    positions[i++] = uvs.x0;\n    positions[i++] = uvs.y0;\n\n    // color\n    colors[i++] = color;\n\n    // texture index\n    positions[i++] = textureIndex;\n\n    // xy\n    positions[i++] = (a * w0 + c * h1 + tx);\n    positions[i++] = d * h1 + b * w0 + ty;\n\n    // uv\n    positions[i++] = uvs.x1;\n    positions[i++] = uvs.y1;\n\n    // color\n    colors[i++] = color;\n\n    // texture index\n    positions[i++] = textureIndex;\n\n    // xy\n    positions[i++] = a * w0 + c * h0 + tx;\n    positions[i++] = d * h0 + b * w0 + ty;\n\n    // uv\n    positions[i++] = uvs.x2;\n    positions[i++] = uvs.y2;\n\n    // color\n    colors[i++] = color;\n\n    // texture index\n    positions[i++] = textureIndex;\n\n    // xy\n    positions[i++] = a * w1 + c * h0 + tx;\n    positions[i++] = d * h0 + b * w1 + ty;\n\n    // uv\n    positions[i++] = uvs.x3;\n    positions[i++] = uvs.y3;\n\n    // color\n    colors[i++] = color;\n\n    // texture index\n    positions[i++] = textureIndex;\n\n    // increment the batchsize\n    this.sprites[this.currentBatchSize++] = sprite;\n};\n\n/**\n * Renders the content and empties the current batch.\n *\n * @method PIXI.WebGLSpriteBatch#flush\n */\nPIXI.WebGLSpriteBatch.prototype.flush = function ()\n{\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize === 0)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n    var shader;\n\n    if (this.dirty)\n    {\n        this.dirty = false;\n\n        shader = this.defaultShader.shaders[gl.id];\n\n        // bind the main texture\n        gl.activeTexture(gl.TEXTURE0);\n\n        // bind the buffers\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n        // this is the same for each shader?\n        var stride = this.vertexSize; // this.vertSize * 4;\n        gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n        gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, stride, 8);\n\n        // color attributes will be interpreted as unsigned bytes and normalized\n        gl.vertexAttribPointer(shader.colorAttribute, 4, gl.UNSIGNED_BYTE, true, stride, 16);\n\n        // Texture index\n        gl.vertexAttribPointer(shader.aTextureIndex, 1, gl.FLOAT, false, stride, 20);\n    }\n\n    // upload the verts to the buffer\n    if (this.currentBatchSize > (this.size * 0.5))\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        var view = this.positions.subarray(0, this.currentBatchSize * this.vertexSize);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n\n    var nextTexture, nextBlendMode, nextShader;\n    var batchSize = 0;\n    var start = 0;\n\n    var currentBaseTexture = null;\n    var currentBlendMode = this.renderSession.blendModeManager.currentBlendMode;\n    var currentShader = null;\n\n    var blendSwap = false;\n    var shaderSwap = false;\n    var sprite;\n\n    for (var i = 0, j = this.currentBatchSize; i < j; i++)\n    {\n\n        sprite = this.sprites[i];\n\n        if (sprite.tilingTexture)\n        {\n            nextTexture = sprite.tilingTexture.baseTexture;\n        }\n        else\n        {\n            nextTexture = sprite.texture.baseTexture;\n        }\n\n        nextBlendMode = sprite.blendMode;\n        nextShader = sprite.shader || this.defaultShader;\n\n        blendSwap = currentBlendMode !== nextBlendMode;\n        shaderSwap = currentShader !== nextShader; // should I use _UIDS???\n\n        var skip = nextTexture.skipRender;\n\n        if (skip && sprite.children.length > 0)\n        {\n            skip = false;\n        }\n\n        //\n        if (/* (currentBaseTexture != nextTexture && !skip) || */\n            blendSwap ||\n            shaderSwap)\n        {\n            this.renderBatch(currentBaseTexture, batchSize, start);\n\n            start = i;\n            batchSize = 0;\n            currentBaseTexture = nextTexture;\n\n            if (blendSwap)\n            {\n                currentBlendMode = nextBlendMode;\n                this.renderSession.blendModeManager.setBlendMode(currentBlendMode);\n            }\n\n            if (shaderSwap)\n            {\n                currentShader = nextShader;\n\n                shader = currentShader.shaders[gl.id];\n\n                if (!shader)\n                {\n                    shader = new PIXI.PixiShader(gl);\n\n                    shader.fragmentSrc = currentShader.fragmentSrc;\n                    shader.uniforms = currentShader.uniforms;\n                    shader.init();\n\n                    currentShader.shaders[gl.id] = shader;\n                }\n\n                // set shader function???\n                this.renderSession.shaderManager.setShader(shader);\n\n                if (shader.dirty)\n                {\n                    shader.syncUniforms();\n                }\n\n                // both these only need to be set if they are changing..\n                // set the projection\n                var projection = this.renderSession.projection;\n                gl.uniform2f(shader.projectionVector, projection.x, projection.y);\n\n                // TODO - this is temporary!\n                var offsetVector = this.renderSession.offset;\n                gl.uniform2f(shader.offsetVector, offsetVector.x, offsetVector.y);\n\n                // set the pointers\n            }\n        }\n\n        batchSize++;\n    }\n\n    this.renderBatch(currentBaseTexture, batchSize, start);\n\n    // then reset the batch!\n    this.currentBatchSize = 0;\n};\n\n/**\n * @method PIXI.WebGLSpriteBatch#renderBatch\n * @param texture {Texture}\n * @param size {Number}\n * @param startIndex {Number}\n */\nPIXI.WebGLSpriteBatch.prototype.renderBatch = function (texture, size, startIndex)\n{\n    if (size === 0)\n    {\n        return;\n    }\n\n    var gl = this.gl;\n\n    // check if a texture is dirty..\n    if (texture._dirty[gl.id])\n    {\n        if (!this.renderSession.renderer.updateTexture(texture))\n        {\n            //  If updateTexture returns false then we cannot render it, so bail out now\n            return;\n        }\n    }\n    else\n    {\n        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n    }\n\n    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);\n\n    // increment the draw count\n    this.renderSession.drawCount++;\n};\n\n/**\n * @method PIXI.WebGLSpriteBatch#stop\n */\nPIXI.WebGLSpriteBatch.prototype.stop = function ()\n{\n    this.flush();\n    this.dirty = true;\n};\n\n/**\n * @method PIXI.WebGLSpriteBatch#start\n */\nPIXI.WebGLSpriteBatch.prototype.start = function ()\n{\n    this.dirty = true;\n};\n\n/**\n * Destroys the SpriteBatch.\n *\n * @method PIXI.WebGLSpriteBatch#destroy\n */\nPIXI.WebGLSpriteBatch.prototype.destroy = function ()\n{\n    this.vertices = null;\n    this.indices = null;\n\n    this.gl.deleteBuffer(this.vertexBuffer);\n    this.gl.deleteBuffer(this.indexBuffer);\n\n    this.currentBaseTexture = null;\n\n    this.gl = null;\n};\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n *\n * Heavily inspired by LibGDX's WebGLSpriteBatch:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/WebGLSpriteBatch.java\n */\n\n/**\n* @class PIXI.WebGLFastSpriteBatch\n* @constructor\n*/\nPIXI.WebGLFastSpriteBatch = function (gl)\n{\n\n    /**\n     * @property vertSize\n     * @type Number\n     */\n    this.vertSize = 11;\n\n    /**\n     * @property maxSize\n     * @type Number\n     */\n    this.maxSize = 6000;// Math.pow(2, 16) /  this.vertSize;\n\n    /**\n     * @property size\n     * @type Number\n     */\n    this.size = this.maxSize;\n\n    // the total number of floats in our batch\n    var numVerts = this.size * 4 * this.vertSize;\n\n    // the total number of indices in our batch\n    var numIndices = this.maxSize * 6;\n\n    /**\n     * Vertex data\n     * @property vertices\n     * @type Float32Array\n     */\n    this.vertices = new Float32Array(numVerts);\n\n    /**\n     * Index data\n     * @property indices\n     * @type Uint16Array\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    /**\n     * @property vertexBuffer\n     * @type Object\n     */\n    this.vertexBuffer = null;\n\n    /**\n     * @property indexBuffer\n     * @type Object\n     */\n    this.indexBuffer = null;\n\n    /**\n     * @property lastIndexCount\n     * @type Number\n     */\n    this.lastIndexCount = 0;\n\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * @property drawing\n     * @type Boolean\n     */\n    this.drawing = false;\n\n    /**\n     * @property currentBatchSize\n     * @type Number\n     */\n    this.currentBatchSize = 0;\n\n    /**\n     * @property currentBaseTexture\n     * @type BaseTexture\n     */\n    this.currentBaseTexture = null;\n\n    /**\n     * @property currentBlendMode\n     * @type Number\n     */\n    this.currentBlendMode = 0;\n\n    /**\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = null;\n\n    /**\n     * @property shader\n     * @type Object\n     */\n    this.shader = null;\n\n    /**\n     * @property matrix\n     * @type Matrix\n     */\n    this.matrix = null;\n\n    this.setContext(gl);\n};\n\nPIXI.WebGLFastSpriteBatch.prototype.constructor = PIXI.WebGLFastSpriteBatch;\n\n/**\n * Sets the WebGL Context.\n *\n * @method PIXI.WebGLFastSpriteBatch#setContext\n * @param gl {WebGLContext} the current WebGL drawing context\n */\nPIXI.WebGLFastSpriteBatch.prototype.setContext = function (gl)\n{\n    this.gl = gl;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n    // upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n};\n\n/**\n * @method PIXI.WebGLFastSpriteBatch#begin\n * @param spriteBatch {WebGLSpriteBatch}\n * @param renderSession {Object}\n */\nPIXI.WebGLFastSpriteBatch.prototype.begin = function (spriteBatch, renderSession)\n{\n    this.renderSession = renderSession;\n    this.shader = this.renderSession.shaderManager.fastShader;\n\n    this.matrix = spriteBatch.worldTransform.toArray(true);\n\n    this.start();\n};\n\n/**\n * @method PIXI.WebGLFastSpriteBatch#end\n */\nPIXI.WebGLFastSpriteBatch.prototype.end = function ()\n{\n    this.flush();\n};\n\n/**\n * @method PIXI.WebGLFastSpriteBatch#render\n * @param spriteBatch {WebGLSpriteBatch}\n */\nPIXI.WebGLFastSpriteBatch.prototype.render = function (spriteBatch)\n{\n    var children = spriteBatch.children;\n    var sprite = children[0];\n\n    // if the uvs have not updated then no point rendering just yet!\n\n    // check texture.\n    if(!sprite.texture._uvs) { return; }\n\n    this.currentBaseTexture = sprite.texture.baseTexture;\n\n    // check blend mode\n    if(sprite.blendMode !== this.renderSession.blendModeManager.currentBlendMode)\n    {\n        this.flush();\n        this.renderSession.blendModeManager.setBlendMode(sprite.blendMode);\n    }\n\n    for(var i = 0,j = children.length; i < j; i++)\n    {\n        this.renderSprite(children[i]);\n    }\n\n    this.flush();\n};\n\n/**\n * @method PIXI.WebGLFastSpriteBatch#renderSprite\n * @param sprite {Sprite}\n */\nPIXI.WebGLFastSpriteBatch.prototype.renderSprite = function (sprite)\n{\n    var texture = sprite.texture;\n    var baseTexture = texture.baseTexture;\n    var gl = this.gl;\n    var textureIndex = sprite.texture.baseTexture.textureIndex;\n\n    if (PIXI.WebGLRenderer.textureArray[textureIndex] != baseTexture && // eslint-disable-line eqeqeq\n        baseTexture._glTextures[gl.id] && !sprite.texture.baseTexture.skipRender)\n    {\n        this.flush();\n        gl.activeTexture(gl.TEXTURE0 + textureIndex);\n        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);\n        PIXI.WebGLRenderer.textureArray[textureIndex] = baseTexture;\n        if(!sprite.texture._uvs) { return; }\n\n    }\n\n    // sprite = children[i];\n    if(!sprite.visible) { return; }\n\n    var uvs,\n        vertices = this.vertices,\n        width, height, w0, w1, h0, h1, index;\n\n    uvs = sprite.texture._uvs;\n\n    width = sprite.texture.frame.width;\n    height = sprite.texture.frame.height;\n\n    if (sprite.texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n        var trim = sprite.texture.trim;\n\n        w1 = trim.x - sprite.anchor.x * trim.width;\n        w0 = w1 + sprite.texture.crop.width;\n\n        h1 = trim.y - sprite.anchor.y * trim.height;\n        h0 = h1 + sprite.texture.crop.height;\n    }\n    else\n    {\n        w0 = width * (1 - sprite.anchor.x);\n        w1 = width * -sprite.anchor.x;\n\n        h0 = height * (1 - sprite.anchor.y);\n        h1 = height * -sprite.anchor.y;\n    }\n\n    index = this.currentBatchSize * 4 * this.vertSize;\n\n    // xy\n    vertices[index++] = w1;\n    vertices[index++] = h1;\n\n    vertices[index++] = sprite.position.x;\n    vertices[index++] = sprite.position.y;\n\n    // scale\n    vertices[index++] = sprite.scale.x;\n    vertices[index++] = sprite.scale.y;\n\n    // rotation\n    vertices[index++] = sprite.rotation;\n\n    // uv\n    vertices[index++] = uvs.x0;\n    vertices[index++] = uvs.y1;\n\n    // color\n    vertices[index++] = sprite.alpha;\n\n    // texture Index\n    vertices[index++] = textureIndex;\n\n\n    // xy\n    vertices[index++] = w0;\n    vertices[index++] = h1;\n\n    vertices[index++] = sprite.position.x;\n    vertices[index++] = sprite.position.y;\n\n    // scale\n    vertices[index++] = sprite.scale.x;\n    vertices[index++] = sprite.scale.y;\n\n    // rotation\n    vertices[index++] = sprite.rotation;\n\n    // uv\n    vertices[index++] = uvs.x1;\n    vertices[index++] = uvs.y1;\n\n    // color\n    vertices[index++] = sprite.alpha;\n\n    // texture Index\n    vertices[index++] = textureIndex;\n\n    // xy\n    vertices[index++] = w0;\n    vertices[index++] = h0;\n\n    vertices[index++] = sprite.position.x;\n    vertices[index++] = sprite.position.y;\n\n    // scale\n    vertices[index++] = sprite.scale.x;\n    vertices[index++] = sprite.scale.y;\n\n    // rotation\n    vertices[index++] = sprite.rotation;\n\n    // uv\n    vertices[index++] = uvs.x2;\n    vertices[index++] = uvs.y2;\n\n    // color\n    vertices[index++] = sprite.alpha;\n\n    // texture Index\n    vertices[index++] = textureIndex;\n\n\n\n    // xy\n    vertices[index++] = w1;\n    vertices[index++] = h0;\n\n    vertices[index++] = sprite.position.x;\n    vertices[index++] = sprite.position.y;\n\n    // scale\n    vertices[index++] = sprite.scale.x;\n    vertices[index++] = sprite.scale.y;\n\n    // rotation\n    vertices[index++] = sprite.rotation;\n\n    // uv\n    vertices[index++] = uvs.x3;\n    vertices[index++] = uvs.y3;\n\n    // color\n    vertices[index++] = sprite.alpha;\n\n    // texture Index\n    vertices[index++] = textureIndex;\n\n    // increment the batchs\n    this.currentBatchSize++;\n\n    if(this.currentBatchSize >= this.size)\n    {\n        this.flush();\n    }\n};\n\n/**\n * @method PIXI.WebGLFastSpriteBatch#flush\n */\nPIXI.WebGLFastSpriteBatch.prototype.flush = function ()\n{\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize === 0) { return; }\n\n    var gl = this.gl;\n\n    // bind the current texture\n\n    if(!this.currentBaseTexture._glTextures[gl.id])\n    {\n        this.renderSession.renderer.updateTexture(this.currentBaseTexture, gl);\n        return;\n    }\n\n    // gl.bindTexture(gl.TEXTURE_2D, this.currentBaseTexture._glTextures[gl.id]);\n\n    // upload the verts to the buffer\n\n    if(this.currentBatchSize > (this.size * 0.5))\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.vertices.subarray(0, this.currentBatchSize * 4 * this.vertSize);\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n\n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, this.currentBatchSize * 6, gl.UNSIGNED_SHORT, 0);\n\n    // then reset the batch!\n    this.currentBatchSize = 0;\n\n    // increment the draw count\n    this.renderSession.drawCount++;\n\n};\n\n\n/**\n * @method PIXI.WebGLFastSpriteBatch#stop\n */\nPIXI.WebGLFastSpriteBatch.prototype.stop = function ()\n{\n    this.flush();\n};\n\n/**\n * @method PIXI.WebGLFastSpriteBatch#start\n */\nPIXI.WebGLFastSpriteBatch.prototype.start = function ()\n{\n    var gl = this.gl;\n\n    // bind the main texture\n    gl.activeTexture(gl.TEXTURE0);\n\n    // bind the buffers\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // set the projection\n    var projection = this.renderSession.projection;\n    gl.uniform2f(this.shader.projectionVector, projection.x, projection.y);\n\n    // set the matrix\n    gl.uniformMatrix3fv(this.shader.uMatrix, false, this.matrix);\n\n    // set the pointers\n    var stride = this.vertSize * 4;\n\n    gl.vertexAttribPointer(this.shader.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n    gl.vertexAttribPointer(this.shader.aPositionCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n    gl.vertexAttribPointer(this.shader.aScale, 2, gl.FLOAT, false, stride, 4 * 4);\n    gl.vertexAttribPointer(this.shader.aRotation, 1, gl.FLOAT, false, stride, 6 * 4);\n    gl.vertexAttribPointer(this.shader.aTextureCoord, 2, gl.FLOAT, false, stride, 7 * 4);\n    gl.vertexAttribPointer(this.shader.colorAttribute, 1, gl.FLOAT, false, stride, 9 * 4);\n    gl.vertexAttribPointer(this.shader.aTextureIndex, 1, gl.FLOAT, false, stride, 10 * 4);\n\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n* @class PIXI.WebGLFilterManager\n* @constructor\n*/\nPIXI.WebGLFilterManager = function ()\n{\n    /**\n     * @property filterStack\n     * @type Array\n     */\n    this.filterStack = [];\n\n    /**\n     * @property offsetX\n     * @type Number\n     */\n    this.offsetX = 0;\n\n    /**\n     * @property offsetY\n     * @type Number\n     */\n    this.offsetY = 0;\n};\n\nPIXI.WebGLFilterManager.prototype.constructor = PIXI.WebGLFilterManager;\n\n/**\n* Initialises the context and the properties.\n*\n* @method PIXI.WebGLFilterManager#setContext\n* @param gl {WebGLContext} the current WebGL drawing context\n*/\nPIXI.WebGLFilterManager.prototype.setContext = function (gl)\n{\n    this.gl = gl;\n    this.texturePool = [];\n\n    this.initShaderBuffers();\n};\n\n/**\n* @method PIXI.WebGLFilterManager#begin\n* @param renderSession {RenderSession}\n* @param buffer {ArrayBuffer}\n*/\nPIXI.WebGLFilterManager.prototype.begin = function (renderSession, buffer)\n{\n    this.renderSession = renderSession;\n    this.defaultShader = renderSession.shaderManager.defaultShader;\n\n    var projection = this.renderSession.projection;\n    this.width = projection.x * 2;\n    this.height = -projection.y * 2;\n    this.buffer = buffer;\n};\n\n/**\n* Applies the filter and adds it to the current filter stack.\n*\n* @method PIXI.WebGLFilterManager#pushFilter\n* @param filterBlock {Object} the filter that will be pushed to the current filter stack\n*/\nPIXI.WebGLFilterManager.prototype.pushFilter = function (filterBlock)\n{\n    var gl = this.gl;\n\n    var projection = this.renderSession.projection;\n    var offset = this.renderSession.offset;\n\n    filterBlock._filterArea = filterBlock.target.filterArea || filterBlock.target.getBounds();\n\n    // >>> modify by nextht\n    filterBlock._previous_stencil_mgr = this.renderSession.stencilManager; // eslint-disable-line camelcase\n    this.renderSession.stencilManager = new PIXI.WebGLStencilManager();\n    this.renderSession.stencilManager.setContext(gl);\n    gl.disable(gl.STENCIL_TEST);\n\n    // <<<  modify by nextht\n\n    // filter program\n    // OPTIMISATION - the first filter is free if its a simple color change?\n    this.filterStack.push(filterBlock);\n\n    var filter = filterBlock.filterPasses[0];\n\n    this.offsetX += filterBlock._filterArea.x;\n    this.offsetY += filterBlock._filterArea.y;\n\n    var texture = this.texturePool.pop();\n    if(!texture)\n    {\n        texture = new PIXI.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);\n    }\n    else\n    {\n        texture.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);\n    }\n\n    gl.bindTexture(gl.TEXTURE_2D, texture.texture);\n\n    var filterArea = filterBlock._filterArea;// filterBlock.target.getBounds();///filterBlock.target.filterArea;\n\n    var padding = filter.padding;\n    filterArea.x -= padding;\n    filterArea.y -= padding;\n    filterArea.width += padding * 2;\n    filterArea.height += padding * 2;\n\n    // cap filter to screen size..\n    if(filterArea.x < 0) { filterArea.x = 0; }\n    if(filterArea.width > this.width) { filterArea.width = this.width; }\n    if(filterArea.y < 0) { filterArea.y = 0; }\n    if(filterArea.height > this.height) { filterArea.height = this.height; }\n\n    // gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,  filterArea.width, filterArea.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, texture.frameBuffer);\n\n    // set view port\n    gl.viewport(0, 0, filterArea.width * this.renderSession.resolution, filterArea.height * this.renderSession.resolution);\n\n    projection.x = filterArea.width / 2;\n    projection.y = -filterArea.height / 2;\n\n    offset.x = -filterArea.x;\n    offset.y = -filterArea.y;\n\n    // update projection\n    // now restore the regular shader..\n    // this.renderSession.shaderManager.setShader(this.defaultShader);\n    // gl.uniform2f(this.defaultShader.projectionVector, filterArea.width/2, -filterArea.height/2);\n    // gl.uniform2f(this.defaultShader.offsetVector, -filterArea.x, -filterArea.y);\n\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0,0,0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    filterBlock._glFilterTexture = texture;\n\n};\n\n/**\n* Removes the last filter from the filter stack and doesn't return it.\n*\n* @method PIXI.WebGLFilterManager#popFilter\n*/\nPIXI.WebGLFilterManager.prototype.popFilter = function ()\n{\n    var gl = this.gl;\n    var filterBlock = this.filterStack.pop();\n    var filterArea = filterBlock._filterArea;\n    var texture = filterBlock._glFilterTexture;\n    var projection = this.renderSession.projection;\n    var offset = this.renderSession.offset;\n\n    if(filterBlock.filterPasses.length > 1)\n    {\n        gl.viewport(0, 0, filterArea.width * this.renderSession.resolution, filterArea.height * this.renderSession.resolution);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n        this.vertexArray[0] = 0;\n        this.vertexArray[1] = filterArea.height;\n\n        this.vertexArray[2] = filterArea.width;\n        this.vertexArray[3] = filterArea.height;\n\n        this.vertexArray[4] = 0;\n        this.vertexArray[5] = 0;\n\n        this.vertexArray[6] = filterArea.width;\n        this.vertexArray[7] = 0;\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n\n        // now set the uvs..\n        this.uvArray[2] = filterArea.width / this.width;\n        this.uvArray[5] = filterArea.height / this.height;\n        this.uvArray[6] = filterArea.width / this.width;\n        this.uvArray[7] = filterArea.height / this.height;\n\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);\n\n        var inputTexture = texture;\n        var outputTexture = this.texturePool.pop();\n        if(!outputTexture) { outputTexture = new PIXI.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution); }\n        outputTexture.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution);\n\n        // need to clear this FBO as it may have some left over elements from a previous filter.\n        gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        gl.disable(gl.BLEND);\n\n        for (var i = 0; i < filterBlock.filterPasses.length - 1; i++)\n        {\n            var filterPass = filterBlock.filterPasses[i];\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, outputTexture.frameBuffer);\n\n            // set texture\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, inputTexture.texture);\n\n            // draw texture..\n            // filterPass.applyFilterPass(filterArea.width, filterArea.height);\n            this.applyFilterPass(filterPass, filterArea, filterArea.width, filterArea.height);\n\n            // swap the textures..\n            var temp = inputTexture;\n            inputTexture = outputTexture;\n            outputTexture = temp;\n        }\n\n        gl.enable(gl.BLEND);\n\n        texture = inputTexture;\n        this.texturePool.push(outputTexture);\n    }\n\n    var filter = filterBlock.filterPasses[filterBlock.filterPasses.length - 1];\n\n    this.offsetX -= filterArea.x;\n    this.offsetY -= filterArea.y;\n\n    var sizeX = this.width;\n    var sizeY = this.height;\n\n    var offsetX = 0;\n    var offsetY = 0;\n\n    var buffer = this.buffer;\n\n    // time to render the filters texture to the previous scene\n    if(this.filterStack.length === 0)\n    {\n        gl.colorMask(true, true, true, true);// this.transparent);\n    }\n    else\n    {\n        var currentFilter = this.filterStack[this.filterStack.length - 1];\n        filterArea = currentFilter._filterArea;\n\n        sizeX = filterArea.width;\n        sizeY = filterArea.height;\n\n        offsetX = filterArea.x;\n        offsetY = filterArea.y;\n\n        buffer = currentFilter._glFilterTexture.frameBuffer;\n    }\n\n    // TODO need to remove these global elements..\n    projection.x = sizeX / 2;\n    projection.y = -sizeY / 2;\n\n    offset.x = offsetX;\n    offset.y = offsetY;\n\n    filterArea = filterBlock._filterArea;\n\n    var x = filterArea.x - offsetX;\n    var y = filterArea.y - offsetY;\n\n    // update the buffers..\n    // make sure to flip the y!\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n    this.vertexArray[0] = x;\n    this.vertexArray[1] = y + filterArea.height;\n\n    this.vertexArray[2] = x + filterArea.width;\n    this.vertexArray[3] = y + filterArea.height;\n\n    this.vertexArray[4] = x;\n    this.vertexArray[5] = y;\n\n    this.vertexArray[6] = x + filterArea.width;\n    this.vertexArray[7] = y;\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertexArray);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n\n    this.uvArray[2] = filterArea.width / this.width;\n    this.uvArray[5] = filterArea.height / this.height;\n    this.uvArray[6] = filterArea.width / this.width;\n    this.uvArray[7] = filterArea.height / this.height;\n\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvArray);\n\n    gl.viewport(0, 0, sizeX * this.renderSession.resolution, sizeY * this.renderSession.resolution);\n\n    // bind the buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, buffer);\n\n    // set the blend mode!\n    // gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)\n\n    // set texture\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, texture.texture);\n\n    // >>> modify by nextht\n    if (this.renderSession.stencilManager)\n    {\n        this.renderSession.stencilManager.destroy();\n    }\n    this.renderSession.stencilManager = filterBlock._previous_stencil_mgr; // eslint-disable-line camelcase\n    filterBlock._previous_stencil_mgr = null; // eslint-disable-line camelcase\n    if (this.renderSession.stencilManager.count > 0)\n    {\n        gl.enable(gl.STENCIL_TEST);\n    }\n    else\n    {\n        gl.disable(gl.STENCIL_TEST);\n    }\n\n    // <<< modify by nextht\n\n    // apply!\n    this.applyFilterPass(filter, filterArea, sizeX, sizeY);\n\n    // now restore the regular shader.. should happen automatically now..\n    // this.renderSession.shaderManager.setShader(this.defaultShader);\n    // gl.uniform2f(this.defaultShader.projectionVector, sizeX/2, -sizeY/2);\n    // gl.uniform2f(this.defaultShader.offsetVector, -offsetX, -offsetY);\n\n    // return the texture to the pool\n    this.texturePool.push(texture);\n    filterBlock._glFilterTexture = null;\n};\n\n\n/**\n* Applies the filter to the specified area.\n*\n* @method PIXI.WebGLFilterManager#applyFilterPass\n* @param filter {Phaser.Filter} the filter that needs to be applied\n* @param filterArea {Texture} TODO - might need an update\n* @param width {Number} the horizontal range of the filter\n* @param height {Number} the vertical range of the filter\n*/\nPIXI.WebGLFilterManager.prototype.applyFilterPass = function (filter, filterArea, width, height)\n{\n    // use program\n    var gl = this.gl;\n    var shader = filter.shaders[gl.id];\n\n    if(!shader)\n    {\n        shader = new PIXI.PixiShader(gl);\n\n        shader.fragmentSrc = filter.fragmentSrc;\n        shader.uniforms = filter.uniforms;\n        shader.init(true);\n\n        filter.shaders[gl.id] = shader;\n    }\n\n    // set the shader\n    this.renderSession.shaderManager.setShader(shader);\n\n    //    gl.useProgram(shader.program);\n\n    gl.uniform2f(shader.projectionVector, width / 2, -height / 2);\n    gl.uniform2f(shader.offsetVector, 0,0);\n\n    if(filter.uniforms.dimensions)\n    {\n        filter.uniforms.dimensions.value[0] = this.width;// width;\n        filter.uniforms.dimensions.value[1] = this.height;// height;\n        filter.uniforms.dimensions.value[2] = this.vertexArray[0];\n        filter.uniforms.dimensions.value[3] = this.vertexArray[5];// filterArea.height;\n    }\n\n    shader.syncUniforms();\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.vertexAttribPointer(shader.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n    gl.vertexAttribPointer(shader.aTextureCoord, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n    gl.vertexAttribPointer(shader.colorAttribute, 2, gl.FLOAT, false, 0, 0);\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // draw the filter...\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n\n    this.renderSession.drawCount++;\n};\n\n/**\n* Initialises the shader buffers.\n*\n* @method PIXI.WebGLFilterManager#initShaderBuffers\n*/\nPIXI.WebGLFilterManager.prototype.initShaderBuffers = function ()\n{\n    var gl = this.gl;\n\n    // create some buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.uvBuffer = gl.createBuffer();\n    this.colorBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    // bind and upload the vertexs..\n    // keep a reference to the vertexFloatData..\n    this.vertexArray = new Float32Array([ 0.0, 0.0,\n        1.0, 0.0,\n        0.0, 1.0,\n        1.0, 1.0 ]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertexArray, gl.STATIC_DRAW);\n\n    // bind and upload the uv buffer\n    this.uvArray = new Float32Array([ 0.0, 0.0,\n        1.0, 0.0,\n        0.0, 1.0,\n        1.0, 1.0 ]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.uvArray, gl.STATIC_DRAW);\n\n    this.colorArray = new Float32Array([ 1.0, 0xFFFFFF,\n        1.0, 0xFFFFFF,\n        1.0, 0xFFFFFF,\n        1.0, 0xFFFFFF ]);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.STATIC_DRAW);\n\n    // bind and upload the index\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([ 0, 1, 2, 1, 3, 2 ]), gl.STATIC_DRAW);\n\n};\n\n/**\n* Destroys the filter and removes it from the filter stack.\n*\n* @method PIXI.WebGLFilterManager#destroy\n*/\nPIXI.WebGLFilterManager.prototype.destroy = function ()\n{\n    var gl = this.gl;\n\n    this.filterStack = null;\n\n    this.offsetX = 0;\n    this.offsetY = 0;\n\n    // destroy textures\n    for (var i = 0; i < this.texturePool.length; i++)\n    {\n        this.texturePool[i].destroy();\n    }\n\n    this.texturePool = null;\n\n    // destroy buffers..\n    gl.deleteBuffer(this.vertexBuffer);\n    gl.deleteBuffer(this.uvBuffer);\n    gl.deleteBuffer(this.colorBuffer);\n    gl.deleteBuffer(this.indexBuffer);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * @private\n */\nfunction _CreateEmptyTexture (gl, width, height, scaleMode)\n{\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, scaleMode === PIXI.scaleModes.LINEAR ? gl.LINEAR : gl.NEAREST);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n    return texture;\n}\n\n/**\n * @private\n */\nvar _fbErrors = {\n    36054: 'Incomplete attachment',\n    36055: 'Missing attachment',\n    36057: 'Incomplete dimensions',\n    36061: 'Framebuffer unsupported'\n};\n\n/**\n * @private\n */\nfunction _CreateFramebuffer (gl, width, height, scaleMode, textureUnit)\n{\n    var framebuffer = gl.createFramebuffer();\n    var depthStencilBuffer = gl.createRenderbuffer();\n    var colorBuffer = null;\n    var fbStatus = 0;\n\n    gl.activeTexture(gl.TEXTURE0 + textureUnit);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n    gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);\n    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.renderBuffer);\n    colorBuffer = _CreateEmptyTexture(gl, width, height, scaleMode);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorBuffer, 0);\n    fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    if(fbStatus !== gl.FRAMEBUFFER_COMPLETE)\n    {\n        console.error('Incomplete GL framebuffer. ', _fbErrors[fbStatus]);\n    }\n    framebuffer.width = width;\n    framebuffer.height = height;\n    framebuffer.targetTexture = colorBuffer;\n    framebuffer.renderBuffer = depthStencilBuffer;\n    return framebuffer;\n}\n\n/**\n* @class PIXI.FilterTexture\n* @constructor\n* @param gl {WebGLContext} the current WebGL drawing context\n* @param width {Number} the horizontal range of the filter\n* @param height {Number} the vertical range of the filter\n* @param scaleMode {Number} See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values\n*/\nPIXI.FilterTexture = function (gl, width, height, scaleMode, textureUnit)\n{\n    textureUnit = typeof textureUnit === 'number' ? textureUnit : 0;\n\n    /**\n     * @property gl\n     * @type WebGLContext\n     */\n    this.gl = gl;\n\n    // next time to create a frame buffer and texture\n\n    /**\n     * @property frameBuffer\n     * @type Any\n     */\n    this.frameBuffer = _CreateFramebuffer(gl, width, height, scaleMode || PIXI.scaleModes.DEFAULT, textureUnit);\n\n    /**\n     * @property texture\n     * @type Any\n     */\n    this.texture = this.frameBuffer.targetTexture;\n    this.width = width;\n    this.height = height;\n    this.renderBuffer = this.frameBuffer.renderBuffer;\n};\n\nPIXI.FilterTexture.prototype.constructor = PIXI.FilterTexture;\n\n/**\n* Clears the filter texture.\n*\n* @method PIXI.FilterTexture#clear\n*/\nPIXI.FilterTexture.prototype.clear = function ()\n{\n    var gl = this.gl;\n\n    gl.clearColor(0,0,0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n};\n\n/**\n * Resizes the texture to the specified width and height\n *\n * @method PIXI.FilterTexture#resize\n * @param width {Number} the new width of the texture\n * @param height {Number} the new height of the texture\n */\nPIXI.FilterTexture.prototype.resize = function (width, height)\n{\n    if(this.width === width && this.height === height) { return; }\n\n    this.width = width;\n    this.height = height;\n\n    var gl = this.gl;\n    gl.bindTexture(gl.TEXTURE_2D, this.texture);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width , height , 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n    // update the stencil buffer width and height\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderBuffer);\n    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width , height);\n};\n\n/**\n* Destroys the filter texture.\n*\n* @method PIXI.FilterTexture#destroy\n*/\nPIXI.FilterTexture.prototype.destroy = function ()\n{\n    var gl = this.gl;\n    gl.deleteFramebuffer(this.frameBuffer);\n    gl.deleteTexture(this.texture);\n\n    this.frameBuffer = null;\n    this.texture = null;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * Creates a Canvas element of the given size.\n *\n * @class PIXI.CanvasBuffer\n * @constructor\n * @param width {Number} the width for the newly created canvas\n * @param height {Number} the height for the newly created canvas\n */\nPIXI.CanvasBuffer = function (width, height)\n{\n    /**\n     * The width of the Canvas in pixels.\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = width;\n\n    /**\n     * The height of the Canvas in pixels.\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = height;\n\n    /**\n     * The Canvas object that belongs to this CanvasBuffer.\n     *\n     * @property canvas\n     * @type HTMLCanvasElement\n     */\n    this.canvas = Phaser.CanvasPool.create(this, this.width, this.height);\n\n    /**\n     * A CanvasRenderingContext2D object representing a two-dimensional rendering context.\n     *\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n    this.context = this.canvas.getContext('2d');\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n};\n\nPIXI.CanvasBuffer.prototype.constructor = PIXI.CanvasBuffer;\n\n/**\n * Clears the canvas that was created by the CanvasBuffer class.\n *\n * @method PIXI.CanvasBuffer#clear\n * @private\n */\nPIXI.CanvasBuffer.prototype.clear = function ()\n{\n    this.context.setTransform(1, 0, 0, 1, 0, 0);\n    this.context.clearRect(0,0, this.width, this.height);\n};\n\n/**\n * Resizes the canvas to the specified width and height.\n *\n * @method PIXI.CanvasBuffer#resize\n * @param width {Number} the new width of the canvas\n * @param height {Number} the new height of the canvas\n */\nPIXI.CanvasBuffer.prototype.resize = function (width, height)\n{\n    this.width = this.canvas.width = width;\n    this.height = this.canvas.height = height;\n};\n\n/**\n * Frees the canvas up for use again.\n *\n * @method PIXI.CanvasBuffer#destroy\n */\nPIXI.CanvasBuffer.prototype.destroy = function ()\n{\n    Phaser.CanvasPool.remove(this);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A set of functions used to handle masking.\n *\n * @class PIXI.CanvasMaskManager\n * @constructor\n */\nPIXI.CanvasMaskManager = function ()\n{\n};\n\nPIXI.CanvasMaskManager.prototype.constructor = PIXI.CanvasMaskManager;\n\n/**\n * This method adds it to the current stack of masks.\n *\n * @method PIXI.CanvasMaskManager#pushMask\n * @param maskData {Object} the maskData that will be pushed\n * @param renderSession {Object} The renderSession whose context will be used for this mask manager.\n */\nPIXI.CanvasMaskManager.prototype.pushMask = function (maskData, renderSession)\n{\n\n    var context = renderSession.context;\n\n    context.save();\n\n    var cacheAlpha = maskData.alpha;\n    var transform = maskData.worldTransform;\n\n    var resolution = renderSession.resolution;\n\n    context.setTransform(transform.a * resolution,\n        transform.b * resolution,\n        transform.c * resolution,\n        transform.d * resolution,\n        transform.tx * resolution,\n        transform.ty * resolution);\n\n    PIXI.CanvasGraphics.renderGraphicsMask(maskData, context);\n\n    context.clip();\n\n    maskData.worldAlpha = cacheAlpha;\n};\n\n/**\n * Restores the current drawing context to the state it was before the mask was applied.\n *\n * @method PIXI.CanvasMaskManager#popMask\n * @param renderSession {Object} The renderSession whose context will be used for this mask manager.\n */\nPIXI.CanvasMaskManager.prototype.popMask = function (renderSession)\n{\n    renderSession.context.restore();\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * Utility methods for Sprite/Texture tinting.\n *\n * @class PIXI.CanvasTinter\n * @static\n */\nPIXI.CanvasTinter = function () {};\n\n/**\n * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n *\n * @method PIXI.CanvasTinter#getTintedTexture\n * @static\n * @param sprite {Sprite} the sprite to tint\n * @param color {Number} the color to use to tint the sprite with\n * @return {HTMLCanvasElement} The tinted canvas\n */\nPIXI.CanvasTinter.getTintedTexture = function (sprite, color)\n{\n    var canvas = sprite.tintedTexture || Phaser.CanvasPool.create(this);\n\n    PIXI.CanvasTinter.tintMethod(sprite.texture, color, canvas);\n\n    return canvas;\n};\n\n/**\n * Tint a texture using the \"multiply\" operation.\n *\n * @method PIXI.CanvasTinter#tintWithMultiply\n * @static\n * @param texture {Texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithMultiply = function (texture, color, canvas)\n{\n    var context = canvas.getContext('2d');\n\n    var crop = texture.crop;\n    var w = crop.width;\n    var h = crop.height;\n\n    if (texture.rotated)\n    {\n        w = h;\n        h = crop.width;\n    }\n\n    if (canvas.width !== w || canvas.height !== h)\n    {\n        canvas.width = w;\n        canvas.height = h;\n    }\n\n    context.clearRect(0, 0, w, h);\n\n    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, w, h);\n\n    context.globalCompositeOperation = 'multiply';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, w, h, 0, 0, w, h);\n\n    context.globalCompositeOperation = 'destination-atop';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, w, h, 0, 0, w, h);\n\n};\n\n/**\n * Tint a texture pixel per pixel.\n *\n * @method PIXI.CanvasTinter#tintPerPixel\n * @static\n * @param texture {Texture} the texture to tint\n * @param color {Number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nPIXI.CanvasTinter.tintWithPerPixel = function (texture, color, canvas)\n{\n    var context = canvas.getContext('2d');\n\n    var crop = texture.crop;\n    var w = crop.width;\n    var h = crop.height;\n\n    if (texture.rotated)\n    {\n        w = h;\n        h = crop.width;\n    }\n\n    if (canvas.width !== w || canvas.height !== h)\n    {\n        canvas.width = w;\n        canvas.height = h;\n    }\n\n    context.globalCompositeOperation = 'copy';\n\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, w, h, 0, 0, w, h);\n\n    var rgbValues = Phaser.Color.hexToRGBArray(color);\n    var r = rgbValues[0],\n        g = rgbValues[1],\n        b = rgbValues[2];\n\n    var pixelData = context.getImageData(0, 0, w, h);\n\n    var pixels = pixelData.data;\n\n    for (var i = 0; i < pixels.length; i += 4)\n    {\n        pixels[i + 0] *= r;\n        pixels[i + 1] *= g;\n        pixels[i + 2] *= b;\n\n        if (!PIXI.CanvasTinter.canHandleAlpha)\n        {\n            var alpha = pixels[i + 3];\n\n            pixels[i + 0] /= 255 / alpha;\n            pixels[i + 1] /= 255 / alpha;\n            pixels[i + 2] /= 255 / alpha;\n        }\n    }\n\n    context.putImageData(pixelData, 0, 0);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * The CanvasRenderer draws the Stage and all its content onto a 2d canvas. This renderer should be used for browsers that do not support webGL.\n * Don't forget to add the CanvasRenderer.view to your DOM or you will not see anything :)\n *\n * @class PIXI.CanvasRenderer\n * @constructor\n * @param game {Phaser.Game} A reference to the Phaser Game instance\n */\nPIXI.CanvasRenderer = function (game, config)\n{\n\n    /**\n    * @property {Phaser.Game} game - A reference to the Phaser Game instance.\n    */\n    this.game = game;\n\n    if (!PIXI.defaultRenderer)\n    {\n        PIXI.defaultRenderer = this;\n    }\n\n    /**\n     * The renderer type.\n     *\n     * @property type\n     * @type Number\n     */\n    this.type = Phaser.CANVAS;\n\n    /**\n     * The resolution of the canvas.\n     *\n     * @property resolution\n     * @type Number\n     */\n    this.resolution = game.resolution;\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the Stage is NOT transparent Pixi will use a canvas sized fillRect operation every frame to set the canvas background color.\n     * If the Stage is transparent Pixi will use clearRect to clear the canvas every frame.\n     * Disable this by setting this to false. For example if your game has a canvas filling background image you often don't need this set.\n     *\n     * @property clearBeforeRender\n     * @type Boolean\n     * @default\n     */\n    this.clearBeforeRender = game.clearBeforeRender;\n\n    /**\n     * Whether the render view is transparent\n     *\n     * @property transparent\n     * @type Boolean\n     */\n    this.transparent = game.transparent;\n\n    /**\n     * Whether the render view should be resized automatically\n     *\n     * @property autoResize\n     * @type Boolean\n     */\n    this.autoResize = false;\n\n    /**\n     * The width of the canvas view\n     *\n     * @property width\n     * @type Number\n     * @default 800\n     */\n    this.width = game.width * this.resolution;\n\n    /**\n     * The height of the canvas view\n     *\n     * @property height\n     * @type Number\n     * @default 600\n     */\n    this.height = game.height * this.resolution;\n\n    /**\n     * The canvas element that everything is drawn to.\n     *\n     * @property view\n     * @type HTMLCanvasElement\n     */\n    this.view = game.canvas;\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @property context\n     * @type CanvasRenderingContext2D\n     */\n    this.context = this.view.getContext('2d', { alpha: this.transparent });\n\n    if (!this.context)\n    {\n        throw new Error('Failed to create a Canvas 2d context.');\n    }\n\n    /**\n     * Boolean flag controlling canvas refresh.\n     *\n     * @property refresh\n     * @type Boolean\n     */\n    this.refresh = true;\n\n    /**\n     * Internal var.\n     *\n     * @property count\n     * @type Number\n     */\n    this.count = 0;\n\n    /**\n     * Instance of a PIXI.CanvasMaskManager, handles masking when using the canvas renderer\n     * @property CanvasMaskManager\n     * @type CanvasMaskManager\n     */\n    this.maskManager = new PIXI.CanvasMaskManager();\n\n    /**\n     * The render session is just a bunch of parameter used for rendering\n     * @property renderSession\n     * @type Object\n     */\n    this.renderSession = {\n        context: this.context,\n        maskManager: this.maskManager,\n        scaleMode: null,\n        smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),\n\n        /**\n         * If true Pixi will Math.floor() x/y values when rendering, stopping pixel interpolation.\n         * Handy for crisp pixel art and speed on legacy devices.\n         */\n        roundPixels: config.roundPixels || false\n    };\n\n    this.mapBlendModes();\n\n    this.resize(this.width, this.height);\n\n};\n\n// constructor\nPIXI.CanvasRenderer.prototype.constructor = PIXI.CanvasRenderer;\n\n/**\n * Renders the DisplayObjectContainer, usually the Phaser.Stage, to this canvas view.\n *\n * @method PIXI.CanvasRenderer#render\n * @param root {Phaser.Stage|PIXI.DisplayObjectContainer} The root element to be rendered.\n */\nPIXI.CanvasRenderer.prototype.render = function (root)\n{\n\n    this.context.setTransform(1, 0, 0, 1, 0, 0);\n\n    this.context.globalAlpha = 1;\n\n    this.renderSession.currentBlendMode = 0;\n    this.renderSession.shakeX = this.game.camera._shake.x;\n    this.renderSession.shakeY = this.game.camera._shake.y;\n\n    this.context.globalCompositeOperation = 'source-over';\n\n    if (navigator.isCocoonJS && this.view.screencanvas)\n    {\n        this.context.fillStyle = 'black';\n        this.context.clear();\n    }\n\n    if (this.clearBeforeRender)\n    {\n        if (this.transparent)\n        {\n            this.context.clearRect(0, 0, this.width, this.height);\n        }\n        else if (root._bgColor)\n        {\n            this.context.fillStyle = root._bgColor.rgba;\n            this.context.fillRect(0, 0, this.width , this.height);\n        }\n    }\n\n    this.renderDisplayObject(root);\n\n};\n\nPIXI.CanvasRenderer.prototype.setTexturePriority = function ()\n{\n\n    //  Does nothing on Canvas, but here to allow you to simply set\n    //  `game.renderer.setTexturePriority()` without having to worry about\n    //  running in WebGL or not.\n\n};\n\n/**\n * Removes everything from the renderer and optionally removes the Canvas DOM element.\n *\n * @method PIXI.CanvasRenderer#destroy\n * @param [removeView=true] {boolean} Removes the Canvas element from the DOM.\n */\nPIXI.CanvasRenderer.prototype.destroy = function (removeView)\n{\n\n    if (removeView === undefined) { removeView = true; }\n\n    if (removeView && this.view.parent)\n    {\n        this.view.parent.removeChild(this.view);\n    }\n\n    this.view = null;\n    this.context = null;\n    this.maskManager = null;\n    this.renderSession = null;\n\n};\n\n/**\n * Resizes the canvas view to the specified width and height\n *\n * @method PIXI.CanvasRenderer#resize\n * @param width {Number} the new width of the canvas view\n * @param height {Number} the new height of the canvas view\n */\nPIXI.CanvasRenderer.prototype.resize = function (width, height)\n{\n\n    this.width = width * this.resolution;\n    this.height = height * this.resolution;\n\n    this.view.width = this.width;\n    this.view.height = this.height;\n\n    if (this.autoResize)\n    {\n        this.view.style.width = this.width / this.resolution + 'px';\n        this.view.style.height = this.height / this.resolution + 'px';\n    }\n\n    if (this.renderSession.smoothProperty)\n    {\n        this.context[this.renderSession.smoothProperty] = (this.renderSession.scaleMode === PIXI.scaleModes.LINEAR);\n    }\n\n};\n\n/**\n * Renders a display object\n *\n * @method PIXI.CanvasRenderer#renderDisplayObject\n * @param displayObject {DisplayObject} The displayObject to render\n * @param context {CanvasRenderingContext2D} the context 2d method of the canvas\n * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n * @private\n */\nPIXI.CanvasRenderer.prototype.renderDisplayObject = function (displayObject, context, matrix)\n{\n\n    this.renderSession.context = context || this.context;\n    this.renderSession.resolution = this.resolution;\n    displayObject._renderCanvas(this.renderSession, matrix);\n\n};\n\n/**\n * Maps Pixi blend modes to canvas blend modes.\n *\n * @method PIXI.CanvasRenderer#mapBlendModes\n * @private\n */\nPIXI.CanvasRenderer.prototype.mapBlendModes = function ()\n{\n\n    if (!PIXI.blendModesCanvas)\n    {\n        var b = [];\n        var modes = PIXI.blendModes;\n        var useNew = this.game.device.canUseMultiply;\n\n        b[modes.NORMAL] = 'source-over';\n        b[modes.ADD] = 'lighter';\n        b[modes.MULTIPLY] = (useNew) ? 'multiply' : 'source-over';\n        b[modes.SCREEN] = (useNew) ? 'screen' : 'source-over';\n        b[modes.OVERLAY] = (useNew) ? 'overlay' : 'source-over';\n        b[modes.DARKEN] = (useNew) ? 'darken' : 'source-over';\n        b[modes.LIGHTEN] = (useNew) ? 'lighten' : 'source-over';\n        b[modes.COLOR_DODGE] = (useNew) ? 'color-dodge' : 'source-over';\n        b[modes.COLOR_BURN] = (useNew) ? 'color-burn' : 'source-over';\n        b[modes.HARD_LIGHT] = (useNew) ? 'hard-light' : 'source-over';\n        b[modes.SOFT_LIGHT] = (useNew) ? 'soft-light' : 'source-over';\n        b[modes.DIFFERENCE] = (useNew) ? 'difference' : 'source-over';\n        b[modes.EXCLUSION] = (useNew) ? 'exclusion' : 'source-over';\n        b[modes.HUE] = (useNew) ? 'hue' : 'source-over';\n        b[modes.SATURATION] = (useNew) ? 'saturation' : 'source-over';\n        b[modes.COLOR] = (useNew) ? 'color' : 'source-over';\n        b[modes.LUMINOSITY] = (useNew) ? 'luminosity' : 'source-over';\n\n        PIXI.blendModesCanvas = b;\n    }\n\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * A texture stores the information that represents an image. All textures have a base texture.\n *\n * @class PIXI.BaseTexture\n * @constructor\n * @param source {String|Canvas} the source object (image or canvas)\n * @param scaleMode {Number} See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values\n * @param [resolution] {Number} the resolution of the texture (for HiDPI displays)\n */\nPIXI.BaseTexture = function (source, scaleMode, resolution)\n{\n    /**\n     * The Resolution of the texture.\n     *\n     * @property resolution\n     * @type Number\n     */\n    this.resolution = resolution || 1;\n\n    /**\n     * [read-only] The width of the base texture set when the image has loaded\n     *\n     * @property width\n     * @type Number\n     * @readOnly\n     */\n    this.width = 100;\n\n    /**\n     * [read-only] The height of the base texture set when the image has loaded\n     *\n     * @property height\n     * @type Number\n     * @readOnly\n     */\n    this.height = 100;\n\n    /**\n     * The scale mode to apply when scaling this texture\n     *\n     * @property scaleMode\n     * @type {Number}\n     * @default PIXI.scaleModes.LINEAR\n     */\n    this.scaleMode = scaleMode || PIXI.scaleModes.DEFAULT;\n\n    /**\n     * [read-only] Set to true once the base texture has loaded\n     *\n     * @property hasLoaded\n     * @type Boolean\n     * @readOnly\n     */\n    this.hasLoaded = false;\n\n    /**\n     * The image source that is used to create the texture.\n     *\n     * @property source\n     * @type Image\n     */\n    this.source = source;\n\n    /**\n     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)\n     *\n     * @property premultipliedAlpha\n     * @type Boolean\n     * @default true\n     */\n    this.premultipliedAlpha = true;\n\n    // used for webGL\n\n    /**\n     * @property _glTextures\n     * @type Array\n     * @private\n     */\n    this._glTextures = [];\n\n    /**\n     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used\n     * Also the texture must be a power of two size to work\n     *\n     * @property mipmap\n     * @type {Boolean}\n     */\n    this.mipmap = false;\n\n    /**\n     * The multi texture batching index number.\n     * @property textureIndex\n     * @type Number\n     */\n    this.textureIndex = 0;\n\n    /**\n     * @property _dirty\n     * @type Array\n     * @private\n     */\n    this._dirty = [ true, true, true, true ];\n\n    if (!source)\n    {\n        return;\n    }\n\n    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)\n    {\n        this.hasLoaded = true;\n        this.width = this.source.naturalWidth || this.source.width;\n        this.height = this.source.naturalHeight || this.source.height;\n        this.dirty();\n    }\n\n    /**\n     * A BaseTexture can be set to skip the rendering phase in the WebGL Sprite Batch.\n     *\n     * You may want to do this if you have a parent Sprite with no visible texture (i.e. uses the internal `__default` texture)\n     * that has children that you do want to render, without causing a batch flush in the process.\n     *\n     * @property skipRender\n     * @type Boolean\n     */\n    this.skipRender = false;\n\n    /**\n     * @property _powerOf2\n     * @type Boolean\n     * @private\n     */\n    this._powerOf2 = false;\n\n};\n\nPIXI.BaseTexture.prototype.constructor = PIXI.BaseTexture;\n\n/**\n * Forces this BaseTexture to be set as loaded, with the given width and height.\n * Then calls BaseTexture.dirty.\n * Important for when you don't want to modify the source object by forcing in `complete` or dimension properties it may not have.\n *\n * @method PIXI.BaseTexture#forceLoaded\n * @param {number} width - The new width to force the BaseTexture to be.\n * @param {number} height - The new height to force the BaseTexture to be.\n */\nPIXI.BaseTexture.prototype.forceLoaded = function (width, height)\n{\n    this.hasLoaded = true;\n    this.width = width;\n    this.height = height;\n    this.dirty();\n};\n\n/**\n * Destroys this base texture\n *\n * @method PIXI.BaseTexture#destroy\n */\nPIXI.BaseTexture.prototype.destroy = function ()\n{\n    if (this.source)\n    {\n        Phaser.CanvasPool.removeByCanvas(this.source);\n    }\n\n    this.source = null;\n\n    this.unloadFromGPU();\n};\n\n/**\n * Sets all glTextures to be dirty.\n *\n * @method PIXI.BaseTexture#dirty\n */\nPIXI.BaseTexture.prototype.dirty = function ()\n{\n    for (var i = 0; i < this._glTextures.length; i++)\n    {\n        this._dirty[i] = true;\n    }\n};\n\n/**\n * Removes the base texture from the GPU, useful for managing resources on the GPU.\n * Atexture is still 100% usable and will simply be reuploaded if there is a sprite on screen that is using it.\n *\n * @method PIXI.BaseTexture#unloadFromGPU\n */\nPIXI.BaseTexture.prototype.unloadFromGPU = function ()\n{\n    this.dirty();\n\n    // delete the webGL textures if any.\n    for (var i = this._glTextures.length - 1; i >= 0; i--)\n    {\n        var glTexture = this._glTextures[i];\n        var gl = PIXI.glContexts[i];\n\n        if(gl && glTexture)\n        {\n            gl.deleteTexture(glTexture);\n        }\n\n    }\n\n    this._glTextures.length = 0;\n\n    this.dirty();\n};\n\n/**\n * Helper function that creates a base texture from the given canvas element.\n *\n * @static\n * @method PIXI.BaseTexture#fromCanvas\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {Number} See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values\n * @param [resolution] {Number} the resolution of the texture (for HiDPI displays)\n * @return {BaseTexture}\n */\nPIXI.BaseTexture.fromCanvas = function (canvas, scaleMode, resolution)\n{\n    if (canvas.width === 0)\n    {\n        canvas.width = 1;\n    }\n\n    if (canvas.height === 0)\n    {\n        canvas.height = 1;\n    }\n\n    resolution = resolution || 1;\n\n    return new PIXI.BaseTexture(canvas, scaleMode, resolution);\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n/**\n * TextureSilentFail is a boolean that defaults to `false`.\n * If `true` then {@link PIXI.Texture#setFrame} will no longer throw an error if the texture dimensions are incorrect.\n * Instead {@link PIXI.Texture#valid} will be set to `false` (#1556)\n *\n * @type {boolean}\n */\nPIXI.TextureSilentFail = false;\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a PIXI.Sprite. If no frame is provided then the whole image is used.\n *\n * @class PIXI.Texture\n * @constructor\n * @param baseTexture {BaseTexture} The base texture source to create the texture from\n * @param frame {Rectangle} The rectangle frame of the texture to show\n * @param [crop] {Rectangle} The area of original texture\n * @param [trim] {Rectangle} Trimmed texture rectangle\n */\nPIXI.Texture = function (baseTexture, frame, crop, trim)\n{\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * @property noFrame\n     * @type Boolean\n     */\n    this.noFrame = false;\n\n    if (!frame)\n    {\n        this.noFrame = true;\n        frame = new PIXI.Rectangle(0,0,1,1);\n    }\n\n    if (baseTexture instanceof PIXI.Texture)\n    {\n        baseTexture = baseTexture.baseTexture;\n    }\n\n    /**\n     * The base texture that this texture uses.\n     *\n     * @property baseTexture\n     * @type BaseTexture\n     */\n    this.baseTexture = baseTexture;\n\n    /**\n     * The frame specifies the region of the base texture that this texture uses\n     *\n     * @property frame\n     * @type Rectangle\n     */\n    this.frame = frame;\n\n    /**\n     * The texture trim data.\n     *\n     * @property trim\n     * @type Rectangle\n     */\n    this.trim = trim;\n\n    /**\n     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n     *\n     * @property valid\n     * @type Boolean\n     */\n    this.valid = false;\n\n    /**\n     * Is this a tiling texture? As used by the likes of a TilingSprite.\n     *\n     * @property isTiling\n     * @type Boolean\n     */\n    this.isTiling = false;\n\n    /**\n     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n     *\n     * @property requiresUpdate\n     * @type Boolean\n     */\n    this.requiresUpdate = false;\n\n    /**\n     * This will let a renderer know that a tinted parent has updated its texture.\n     *\n     * @property requiresReTint\n     * @type Boolean\n     */\n    this.requiresReTint = false;\n\n    /**\n     * The WebGL UV data cache.\n     *\n     * @property _uvs\n     * @type Object\n     * @private\n     */\n    this._uvs = null;\n\n    /**\n     * The width of the Texture in pixels.\n     *\n     * @property width\n     * @type Number\n     */\n    this.width = 0;\n\n    /**\n     * The height of the Texture in pixels.\n     *\n     * @property height\n     * @type Number\n     */\n    this.height = 0;\n\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     *\n     * @property crop\n     * @type Rectangle\n     */\n    this.crop = crop || new PIXI.Rectangle(0, 0, 1, 1);\n\n    /**\n     * A flag that controls if this frame is rotated or not.\n     * Rotation allows you to use rotated frames in texture atlas packing, it has nothing to do with\n     * Sprite rotation.\n     *\n     * @property rotated\n     * @type Boolean\n     */\n    this.rotated = false;\n\n    if (baseTexture.hasLoaded)\n    {\n        if (this.noFrame) { frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height); }\n        this.setFrame(frame);\n    }\n\n};\n\nPIXI.Texture.prototype.constructor = PIXI.Texture;\n\n/**\n * Called when the base texture is loaded\n *\n * @method PIXI.Texture#onBaseTextureLoaded\n * @private\n */\nPIXI.Texture.prototype.onBaseTextureLoaded = function ()\n{\n    var baseTexture = this.baseTexture;\n\n    if (this.noFrame)\n    {\n        this.frame = new PIXI.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n    }\n\n    this.setFrame(this.frame);\n};\n\n/**\n * Destroys this texture\n *\n * @method PIXI.Texture#destroy\n * @param destroyBase {Boolean} Whether to destroy the base texture as well\n */\nPIXI.Texture.prototype.destroy = function (destroyBase)\n{\n    if (destroyBase) { this.baseTexture.destroy(); }\n\n    this.valid = false;\n};\n\n/**\n * Specifies the region of the baseTexture that this texture will use.\n *\n * @method PIXI.Texture#setFrame\n * @param frame {Rectangle} The frame of the texture to set it to\n */\nPIXI.Texture.prototype.setFrame = function (frame)\n{\n    this.noFrame = false;\n\n    this.frame = frame;\n    this.width = frame.width;\n    this.height = frame.height;\n\n    this.crop.x = frame.x;\n    this.crop.y = frame.y;\n    this.crop.width = frame.width;\n    this.crop.height = frame.height;\n\n    if (!this.trim && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))\n    {\n        if (!PIXI.TextureSilentFail)\n        {\n            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);\n        }\n\n        this.valid = false;\n        return;\n    }\n\n    this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;\n\n    if (this.trim)\n    {\n        this.width = this.trim.width;\n        this.height = this.trim.height;\n        this.frame.width = this.trim.width;\n        this.frame.height = this.trim.height;\n    }\n\n    if (this.valid) { this._updateUvs(); }\n\n};\n\n/**\n * Updates the internal WebGL UV cache.\n *\n * @method PIXI.Texture#_updateUvs\n * @private\n */\nPIXI.Texture.prototype._updateUvs = function ()\n{\n    if(!this._uvs) { this._uvs = new PIXI.TextureUvs(); }\n\n    var frame = this.crop;\n    var tw = this.baseTexture.width;\n    var th = this.baseTexture.height;\n\n    this._uvs.x0 = frame.x / tw;\n    this._uvs.y0 = frame.y / th;\n\n    this._uvs.x1 = (frame.x + frame.width) / tw;\n    this._uvs.y1 = frame.y / th;\n\n    this._uvs.x2 = (frame.x + frame.width) / tw;\n    this._uvs.y2 = (frame.y + frame.height) / th;\n\n    this._uvs.x3 = frame.x / tw;\n    this._uvs.y3 = (frame.y + frame.height) / th;\n};\n\n/**\n * Updates the internal WebGL UV cache.\n *\n * @method PIXI.Texture#_updateUvsInverted\n * @private\n */\nPIXI.Texture.prototype._updateUvsInverted = function ()\n{\n\n    if (!this._uvs) { this._uvs = new PIXI.TextureUvs(); }\n\n    var frame = this.crop;\n    var tw = this.baseTexture.width;\n    var th = this.baseTexture.height;\n\n    this._uvs.x0 = frame.x / tw;\n    this._uvs.y0 = frame.y / th;\n\n    this._uvs.x1 = (frame.x + frame.height) / tw;\n    this._uvs.y1 = frame.y / th;\n\n    this._uvs.x2 = (frame.x + frame.height) / tw;\n    this._uvs.y2 = (frame.y + frame.width) / th;\n\n    this._uvs.x3 = frame.x / tw;\n    this._uvs.y3 = (frame.y + frame.width) / th;\n\n};\n\n/**\n * Helper function that creates a new a Texture based on the given canvas element.\n *\n * @static\n * @method PIXI.Texture#fromCanvas\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {Number} See {{#crossLink \"PIXI/scaleModes:property\"}}PIXI.scaleModes{{/crossLink}} for possible values\n * @return {Texture}\n */\nPIXI.Texture.fromCanvas = function (canvas, scaleMode)\n{\n    var baseTexture = PIXI.BaseTexture.fromCanvas(canvas, scaleMode);\n\n    return new PIXI.Texture(baseTexture);\n};\n\nPIXI.TextureUvs = function ()\n{\n    this.x0 = 0;\n    this.y0 = 0;\n\n    this.x1 = 0;\n    this.y1 = 0;\n\n    this.x2 = 0;\n    this.y2 = 0;\n\n    this.x3 = 0;\n    this.y3 = 0;\n};\n\n/**\n * @author Mat Groves http://matgroves.com/ @Doormat23\n */\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = PIXI;\n        }\n        exports.PIXI = PIXI;\n    } else if (typeof define !== 'undefined' && define.amd) {\n        define('PIXI', (function() { return root.PIXI = PIXI; })() );\n    } else {\n        root.PIXI = PIXI;\n    }\n\n    return PIXI;\n}).call(this);"]}